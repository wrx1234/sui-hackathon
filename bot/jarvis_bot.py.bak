#!/usr/bin/env python3
"""
ğŸ¤– Sui DeFi Jarvis Bot â€” @SuiJarvisBot
The Infinite Money Glitch on Sui

Autonomous AI DeFi Agent powered by OpenClaw
Tech Stack: Sui Ã— Cetus Ã— Walrus Ã— Seal
"""

import json, os, time, logging, requests, hashlib, random, re
from datetime import datetime, timezone, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    MessageHandler, filters, ContextTypes
)
from telegram.request import HTTPXRequest

# ==================== é…ç½® ====================
TOKEN = "7825340169:AAEL5DRdPL6E_zR6-eOSu0ttw-AxaHr0yzI"
PROXY = "http://172.18.0.1:7890"
ADMIN_ID = 6633019220
NETWORK = "testnet"
SUI_RPC = f"https://fullnode.{NETWORK}.sui.io:443"
WALRUS_AGGREGATOR = "https://aggregator.walrus-testnet.walrus.space"
DEPLOYED_PACKAGE = "0x737a73b3a146d45694c341a22b62607e5a6e6b6496b91156217a7d2c91f7e65d"
BOT_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BOT_DIR, "data")
os.makedirs(DATA_DIR, exist_ok=True)

HK_TZ = timezone(timedelta(hours=8))

# ==================== åŒè¯­ç³»ç»Ÿ i18n ====================
LANG_FILE = os.path.join(DATA_DIR, "lang_prefs.json")

TEXTS = {
    "main_greeting": {
        "cn": "ğŸ¤– *Sui DeFi Jarvis*\né€‰æ‹©æ“ä½œ:",
        "en": "ğŸ¤– *Sui DeFi Jarvis*\nChoose action:",
    },
    "btn_assets": {"cn": "ğŸ’° èµ„äº§", "en": "ğŸ’° Assets"},
    "btn_swap": {"cn": "ğŸ”„ Swap äº¤æ˜“", "en": "ğŸ”„ Swap"},
    "btn_portfolio": {"cn": "ğŸ“Š æŒä»“", "en": "ğŸ“Š Portfolio"},
    "btn_limit": {"cn": "ğŸ·ï¸ é™ä»·å•", "en": "ğŸ·ï¸ Limit Order"},
    "btn_whale": {"cn": "ğŸ‹ é²¸é±¼è¿½è¸ª", "en": "ğŸ‹ Whale Tracker"},
    "btn_pools": {"cn": "ğŸŒ± æ–°æ± å­", "en": "ğŸŒ± New Pools"},
    "btn_signals": {"cn": "ğŸ“¢ AI ä¿¡å·", "en": "ğŸ“¢ AI Signals"},
    "btn_strategy": {"cn": "ğŸ¤– ç­–ç•¥", "en": "ğŸ¤– Strategy"},
    "btn_mint": {"cn": "ğŸ’ JarvisUSD Mint", "en": "ğŸ’ JarvisUSD Mint"},
    "btn_yield": {"cn": "ğŸ“ˆ æ”¶ç›Š", "en": "ğŸ“ˆ Yield"},
    "btn_walrus": {"cn": "ğŸ˜ Walrus", "en": "ğŸ˜ Walrus"},
    "btn_vault": {"cn": "ğŸ” Vault", "en": "ğŸ” Vault"},
    "btn_social": {"cn": "ğŸ“£ Social", "en": "ğŸ“£ Social"},
    "btn_settings": {"cn": "âš™ï¸ è®¾ç½®", "en": "âš™ï¸ Settings"},
    "btn_help": {"cn": "â“ å¸®åŠ©", "en": "â“ Help"},
    "btn_back": {"cn": "ğŸ”™ è¿”å›ä¸»èœå•", "en": "ğŸ”™ Back to Menu"},
    "lang_choose": {
        "cn": "ğŸŒ *è¯­è¨€è®¾ç½®*\nè¯·é€‰æ‹©è¯­è¨€ / Choose language:",
        "en": "ğŸŒ *Language Settings*\nChoose language / è¯·é€‰æ‹©è¯­è¨€:",
    },
    "lang_set_cn": {"cn": "âœ… è¯­è¨€å·²åˆ‡æ¢ä¸ºä¸­æ–‡", "en": "âœ… è¯­è¨€å·²åˆ‡æ¢ä¸ºä¸­æ–‡"},
    "lang_set_en": {"cn": "âœ… Language set to English", "en": "âœ… Language set to English"},
    "referral_welcome": {
        "cn": "ğŸ‰ ä½ é€šè¿‡å¥½å‹é‚€è¯·åŠ å…¥ï¼",
        "en": "ğŸ‰ You joined via referral!",
    },
    "social_panel_title": {
        "cn": "ğŸ“£ *Viral Social â€” ç—…æ¯’ä¼ æ’­*",
        "en": "ğŸ“£ *Viral Social â€” Growth Engine*",
    },
}

def _load_lang_prefs() -> dict:
    if os.path.exists(LANG_FILE):
        try:
            with open(LANG_FILE) as f: return json.load(f)
        except: pass
    return {}

def _save_lang_prefs(prefs: dict):
    with open(LANG_FILE, "w") as f: json.dump(prefs, f, indent=2)

def get_lang(uid) -> str:
    """è·å–ç”¨æˆ·è¯­è¨€åå¥½ï¼Œé»˜è®¤ä¸­æ–‡"""
    prefs = _load_lang_prefs()
    return prefs.get(str(uid), "cn")

def set_lang(uid, lang: str):
    """è®¾ç½®ç”¨æˆ·è¯­è¨€åå¥½"""
    prefs = _load_lang_prefs()
    prefs[str(uid)] = lang
    _save_lang_prefs(prefs)

def t(uid, key: str) -> str:
    """è·å–ç¿»è¯‘æ–‡æœ¬"""
    lang = get_lang(uid)
    entry = TEXTS.get(key, {})
    return entry.get(lang, entry.get("cn", key))

# === æ‰¹é‡ä¸­è‹±ç¿»è¯‘æ˜ å°„ ===
CN_TO_EN = {
    "æ­£åœ¨æŸ¥è¯¢ä»£å¸ä¿¡æ¯": "Fetching token info",
    "é€‰æ‹©æ“ä½œå¼€å§‹:": "Choose to begin:",
    "æ ¸å¿ƒåŠŸèƒ½:": "Core Features:",
    "é’±åŒ…ä¿¡æ¯": "Wallet Info", "é’±åŒ…å·²å°±ç»ª:": "Wallet Ready:",
    "ä½™é¢:": "Balance:", "æŠ€æœ¯æ ˆ Tech Stack:": "Tech Stack:",
    "å±‚åŒºå—é“¾": "Layer 1", "æœ€ä¼˜è·¯ç”±": "Best Route",
    "å»ä¸­å¿ƒåŒ–æ“ä½œæ—¥å¿—å­˜å‚¨": "Decentralized Log Storage",
    "é“¾ä¸ŠåŠ å¯†ç­–ç•¥æ•°æ®": "On-chain Encrypted Strategy",
    "è¿è¡Œæ—¶ç¯å¢ƒ": "AI Runtime",
    "å‘é€åˆçº¦åœ°å€å³æŸ¥ Token ä¿¡æ¯": "Send contract address to check Token info",
    "è·¨ 30+ DEX æœ€ä¼˜ Swap": "Optimal Swap across 30+ DEXs",
    "æŒä»“é¢æ¿ + AI äº¤æ˜“ä¿¡å·": "Portfolio + AI Trading Signals",
    "é²¸é±¼è¿½è¸ª + æ–°æ± å­å‘ç°": "Whale Tracking + New Pool Discovery",
    "é™ä»·å• + ç­–ç•¥å¼•æ“": "Limit Orders + Strategy Engine",
    "é€‰æ‹©æ“ä½œ:": "Choose action:",
    "æŒä»“æ¦‚è§ˆ": "Portfolio Overview", "æ€»ä»·å€¼:": "Total Value:",
    "ç›ˆäº:": "PnL:", "æš‚æ— æŒä»“": "No positions yet",
    "ä»£å¸ä½™é¢": "Token Balances", "èµ„äº§é¢æ¿": "Asset Panel",
    "æ€»ä½™é¢:": "Total Balance:", "ä½™é¢ä¸è¶³": "Insufficient Balance",
    "å®‰å…¨è¯„åˆ†": "Safety Score", "åˆçº¦å®¡è®¡": "Contract Audit",
    "ä»£å¸ä¿¡æ¯": "Token Info", "åç§°:": "Name:", "ç¬¦å·:": "Symbol:",
    "ç²¾åº¦:": "Decimals:", "æŒæœ‰è€…æ•°:": "Holders:",
    "æ± å­:": "Pool:", "æµåŠ¨æ€§:": "Liquidity:",
    "å°æ—¶æ¶¨è·Œ:": "h Change:", "é£é™©è¯„ä¼°:": "Risk Assessment:",
    "é²¸é±¼è¿½è¸ªå™¨": "Whale Tracker", "æœ€è¿‘é²¸é±¼åŠ¨æ€": "Recent Whale Activity",
    "ä¹°å…¥": "Buy", "å–å‡º": "Sell",
    "æ–°æ± å­å‘ç°å™¨": "New Pool Finder", "æœ€æ–°ä¸Šçº¿æ± å­": "Newest Pools",
    "åˆ›å»ºæ—¶é—´:": "Created:", "äº¤æ˜“ä¿¡å·é¢æ¿": "Signal Panel",
    "å¼ºçƒˆä¹°å…¥": "Strong Buy", "æŒæœ‰": "Hold",
    "ç­–ç•¥é¢æ¿": "Strategy Panel", "æ´»è·ƒç­–ç•¥:": "Active:",
    "è¿è¡Œä¸­": "Running", "æ”¶ç›Š:": "Yield:",
    "é“¸é€ é¢æ¿": "Mint Panel", "å¯ç”¨ä½™é¢:": "Available:",
    "å½“å‰åˆ©ç‡:": "Current Rate:",
    "æ”¶ç›Šé¢æ¿": "Yield Panel", "å¹´åŒ–æ”¶ç›Š:": "APY:",
    "æ€»å­˜å…¥:": "Deposited:", "ç´¯è®¡æ”¶ç›Š:": "Accumulated:",
    "æ—¥å¿—å­˜å‚¨": "Log Storage", "æ€»è®¡:": "Total:", "èšåˆå™¨:": "Aggregator:",
    "æ‰€æœ‰æ“ä½œæ—¥å¿—å®šæœŸä¸Šä¼ ï¼Œç¡®ä¿å®¡è®¡é€æ˜": "All logs uploaded for audit transparency",
    "æ—¥å¿—ä¸Šä¼ ä¸­": "Uploading", "ä¸Šä¼ æˆåŠŸ": "Uploaded",
    "å¤§å°:": "Size:", "å­˜å‚¨æ—¶é—´:": "Duration:", "æ°¸ä¹…": "Permanent",
    "æ•°æ®å·²å®‰å…¨å­˜å‚¨åœ¨ Walrus å»ä¸­å¿ƒåŒ–ç½‘ç»œ": "Data stored on Walrus decentralized network",
    "é“¾ä¸Šé‡‘åº“": "On-chain Vault", "é‡‘åº“åœ°å€:": "Vault:",
    "æ€»é”ä»“:": "Locked:", "ä½ çš„ä»½é¢:": "Your Share:",
    "å¸®åŠ©": "Help", "å‘½ä»¤åˆ—è¡¨": "Commands",
    "æŸ¥çœ‹é’±åŒ…": "View Wallet", "ä»£å¸å…‘æ¢": "Token Swap",
    "æŸ¥çœ‹æŒä»“": "View Portfolio", "é²¸é±¼åŠ¨æ€": "Whale Activity",
    "è¯­è¨€è®¾ç½®": "Language", "ç—…æ¯’ä¼ æ’­": "Viral Social",
    "ä½ çš„é‚€è¯·é“¾æ¥:": "Your referral link:", "å·²é‚€è¯·äººæ•°:": "Referrals:",
    "é‚€è¯·æ’è¡Œæ¦œ": "Referral Leaderboard", "æš‚æ— æ•°æ®": "No data",
    "æ¨æ–‡æ¨¡æ¿": "Tweet Template", "æ“ä½œæ—¥å¿—": "Logs",
    "æš‚æ— æ“ä½œæ—¥å¿—ã€‚è¯•è¯• /start æˆ– /swapï¼": "No logs yet. Try /start or /swap!",
    "æœ€è¿‘æ“ä½œ:": "Recent:", "ç«‹å³ä¸Šä¼ ": "Upload Now",
    "è¿”å›ä¸»èœå•": "Back to Menu", "è¿”å›": "Back",
    "ç¡®è®¤": "Confirm", "å–æ¶ˆ": "Cancel",
    "å­˜å…¥": "Deposit", "æå–": "Withdraw", "åˆ·æ–°": "Refresh",
    "æŸ¥çœ‹é“¾ä¸Š": "View on-chain", "åˆçº¦åœ°å€:": "Contract:",
    "æ­£åœ¨æ‰§è¡Œ": "Executing", "äº¤æ˜“æˆåŠŸ": "Success", "äº¤æ˜“å¤±è´¥": "Failed",
    "æ¨¡æ‹Ÿäº¤æ˜“": "Simulated", "é¢„ä¼°è¾“å‡º:": "Est. output:",
    "è·¯ç”±:": "Route:", "æ»‘ç‚¹:": "Slippage:", "æ‰§è¡Œ Swap": "Execute Swap",
    "ä½¿ç”¨ AI è‡ªä¸»äº¤æ˜“ç­–ç•¥": "AI autonomous trading",
    "è·Ÿè¸ªå¤§æˆ·é’±åŒ…åŠ¨æ€": "Track whale wallets",
    "å‘ç°æ–°ä¸Šçº¿æµåŠ¨æ€§æ± ": "Discover new pools",
    "æ¥æ”¶ AI äº¤æ˜“ä¿¡å·": "AI trading signals",
    "ä¸€é”®åˆ†äº«å’Œé‚€è¯·å¥½å‹": "Share & invite friends",
    "ä¸­è‹±æ–‡åŒè¯­æ”¯æŒ": "Bilingual support",
    "æŸ¥çœ‹æ‰€æœ‰æ“ä½œæ—¥å¿—": "View all logs",
    "å­˜å…¥èµ„é‡‘åˆ°é“¾ä¸Šé‡‘åº“": "Deposit to vault",
    "æå–é‡‘åº“èµ„é‡‘": "Withdraw from vault",
    "æ¨¡æ‹Ÿæ¨¡å¼": "Simulation Mode",
    "æ­£åœ¨è·å–æœ€ä¼˜è·¯ç”±": "Finding best route",
    "è®¾ç½®": "Settings", "ç½‘ç»œ:": "Network:",
    "æ¨¡å¼:": "Mode:", "èµ„äº§": "Assets",
    "æˆ‘æ˜¯ Jarvisï¼Œä½ çš„è‡ªä¸» AI DeFi ä»£ç†ã€‚": "I'm Jarvis, your autonomous AI DeFi agent.",
    "æˆ‘æ˜¯ä½ çš„è‡ªä¸» AI DeFi ä»£ç†": "I'm your autonomous AI DeFi agent",
}

def T(text: str, uid) -> str:
    """Auto-translate Chinese to English based on user language preference."""
    lang = get_lang(uid)
    if lang == "cn":
        return text
    result = text
    for cn, en in CN_TO_EN.items():
        result = result.replace(cn, en)
    return result

# ==================== Referral ç³»ç»Ÿ ====================
REFERRALS_FILE = os.path.join(DATA_DIR, "referrals.json")

def _load_referrals() -> dict:
    if os.path.exists(REFERRALS_FILE):
        try:
            with open(REFERRALS_FILE) as f: return json.load(f)
        except: pass
    return {}

def _save_referrals(refs: dict):
    with open(REFERRALS_FILE, "w") as f: json.dump(refs, f, indent=2)

def record_referral(new_uid: str, referrer_uid: str):
    """è®°å½•æ¨èå…³ç³»"""
    refs = _load_referrals()
    if new_uid == referrer_uid:
        return  # ä¸èƒ½è‡ªå·±æ¨èè‡ªå·±
    if new_uid in refs:
        return  # å·²è¢«æ¨èè¿‡
    refs[new_uid] = {
        "referrer": referrer_uid,
        "time": datetime.now(HK_TZ).isoformat(),
    }
    _save_referrals(refs)
    log_action("referral", f"new:{new_uid} by:{referrer_uid}")

def get_referral_count(uid: str) -> int:
    """ç»Ÿè®¡æŸç”¨æˆ·é‚€è¯·äº†å¤šå°‘äºº"""
    refs = _load_referrals()
    return sum(1 for v in refs.values() if v.get("referrer") == str(uid))

def get_referral_leaderboard(top_n=10) -> list:
    """é‚€è¯·æ’è¡Œæ¦œ"""
    refs = _load_referrals()
    counts = {}
    for v in refs.values():
        r = v.get("referrer", "")
        counts[r] = counts.get(r, 0) + 1
    ranked = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:top_n]
    return ranked

# AI æ¨æ–‡æ¨¡æ¿
TWEET_TEMPLATES = [
    "ğŸš€ Just discovered @SuiJarvisBot â€” the ultimate AI DeFi agent on #Sui! Auto-routing across 30+ DEXs, whale tracking, and AI signals. The Infinite Money Glitch is real! ğŸ’ğŸ¤– #DeFi #Web3",
    "ğŸ¤– My new DeFi co-pilot: @SuiJarvisBot on #Sui\n\nâœ… Smart swap routing\nâœ… Whale alerts\nâœ… AI trading signals\nâœ… Portfolio tracking\n\nThis is the future of DeFi ğŸ”¥ #SuiNetwork",
    "GM! Been using @SuiJarvisBot and it's a game changer ğŸ¯\n\nAI-powered trading on Sui with Cetus aggregation, on-chain logs via Walrus, and encrypted strategies via Seal.\n\nNot financial advice, but DYOR ğŸ‘€ #Sui #AI",
    "ğŸ’¡ Why I'm bullish on @SuiJarvisBot:\n\nğŸŒŠ Sui L1 speed\nğŸ‹ Cetus 30+ DEX routing\nğŸ˜ Walrus transparent logs\nğŸ” Seal encrypted strategies\nğŸ¦ OpenClaw AI runtime\n\nFull stack DeFi AI agent ğŸ¤¯ #Crypto",
    "ğŸ§  AI + DeFi = @SuiJarvisBot\n\nJust set up limit orders, tracked some whales, and got AI signals â€” all in one Telegram bot on #Sui.\n\nThe future is autonomous finance ğŸŒğŸ’° #Web3 #DeFi",
]

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler(os.path.join(DATA_DIR, "jarvis.log"))]
)
log = logging.getLogger("jarvis")

# ==================== ç”¨æˆ·é’±åŒ…ç®¡ç† ====================
WALLETS_FILE = os.path.join(DATA_DIR, "wallets.json")

def load_wallets():
    if os.path.exists(WALLETS_FILE):
        with open(WALLETS_FILE) as f: return json.load(f)
    return {}

def save_wallets(w):
    with open(WALLETS_FILE, "w") as f: json.dump(w, f, indent=2)

def get_or_create_wallet(user_id: str) -> dict:
    wallets = load_wallets()
    if user_id in wallets:
        return wallets[user_id]
    wallet = {
        "address": "0xc3aa5e010270b6fa9f415739127152328f0bf860012577fff4e21569230a9b80",
        "created": datetime.now(HK_TZ).isoformat(),
        "mode": "demo",
    }
    wallets[user_id] = wallet
    save_wallets(wallets)
    log_action("wallet_auto_create", f"user:{user_id}")
    return wallet

# ==================== æ“ä½œæ—¥å¿— ====================
LOG_FILE = os.path.join(DATA_DIR, "operations.json")

def log_action(action: str, detail: str = ""):
    logs = _load_logs()
    logs.append({
        "time": datetime.now(HK_TZ).isoformat(),
        "action": action,
        "detail": detail
    })
    logs = logs[-200:]
    with open(LOG_FILE, "w") as f: json.dump(logs, f, ensure_ascii=False, indent=2)

def _load_logs():
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE) as f: return json.load(f)
        except: pass
    return []

# ==================== Sui RPC è°ƒç”¨ ====================
def sui_rpc(method: str, params: list):
    try:
        r = requests.post(SUI_RPC, json={
            "jsonrpc": "2.0", "id": 1,
            "method": method, "params": params
        }, timeout=10)
        return r.json().get("result")
    except Exception as e:
        log.error(f"RPC error: {e}")
        return None

def get_sui_balance(address: str) -> dict:
    result = sui_rpc("suix_getBalance", [address, "0x2::sui::SUI"])
    if result:
        bal = int(result["totalBalance"]) / 1e9
        return {"sui": bal, "formatted": f"{bal:.4f} SUI"}
    return {"sui": 0, "formatted": "æŸ¥è¯¢å¤±è´¥"}

def get_all_balances(address: str) -> list:
    result = sui_rpc("suix_getAllBalances", [address])
    if not result: return []
    tokens = []
    for item in result:
        ct = item["coinType"]
        bal = int(item["totalBalance"])
        name = ct.split("::")[-1] if "::" in ct else ct
        decimals = 9 if name == "SUI" else 6
        formatted = bal / (10 ** decimals)
        tokens.append({"name": name, "balance": formatted, "raw": bal, "coinType": ct})
    return tokens

def get_recent_txns(address: str, limit=5) -> list:
    result = sui_rpc("suix_queryTransactionBlocks", [{
        "filter": {"FromAddress": address},
        "options": {"showEffects": True, "showInput": False}
    }, None, limit, True])
    if result and "data" in result:
        return result["data"]
    return []

def get_coin_metadata(coin_type: str) -> dict:
    """Get token metadata via suix_getCoinMetadata"""
    result = sui_rpc("suix_getCoinMetadata", [coin_type])
    return result

def get_total_supply(coin_type: str) -> str:
    """Get total supply via suix_getTotalSupply"""
    result = sui_rpc("suix_getTotalSupply", [coin_type])
    if result and "value" in result:
        return result["value"]
    return None

# ==================== é™ä»·å•å­˜å‚¨ ====================
LIMIT_ORDERS_FILE = os.path.join(DATA_DIR, "limit_orders.json")

def load_limit_orders() -> list:
    if os.path.exists(LIMIT_ORDERS_FILE):
        try:
            with open(LIMIT_ORDERS_FILE) as f: return json.load(f)
        except: pass
    return []

def save_limit_orders(orders: list):
    with open(LIMIT_ORDERS_FILE, "w") as f: json.dump(orders, f, ensure_ascii=False, indent=2)

# ==================== Cetus æŠ¥ä»·ï¼ˆæ¨¡æ‹Ÿï¼‰ ====================
SWAP_PAIRS = {
    "SUI/USDC": {"rate": 3.82, "route": "Cetus â†’ DeepBook â†’ Aftermath", "dexes": 3, "pools": 5},
    "USDC/SUI": {"rate": 0.2618, "route": "DeepBook â†’ Turbos â†’ Cetus", "dexes": 3, "pools": 4},
    "SUI/WETH": {"rate": 0.00118, "route": "Cetus â†’ FlowX â†’ KriyaDEX", "dexes": 3, "pools": 6},
    "SUI/CETUS": {"rate": 42.5, "route": "Cetus AMM (Direct)", "dexes": 1, "pools": 1},
    "SUI/USDT": {"rate": 3.81, "route": "Aftermath â†’ BlueFin â†’ Cetus", "dexes": 3, "pools": 4},
}

# ==================== AI ç­–ç•¥å¼•æ“ ====================
STRATEGIES = {
    "trend": {
        "name": "ğŸ“ˆ è¶‹åŠ¿è·Ÿè¸ª Trend Following",
        "desc": "è·Ÿè¸ªå¤§è¶‹åŠ¿ï¼Œé¡ºåŠ¿äº¤æ˜“ã€‚When SUI shows sustained momentum, ride the wave.",
        "signals": ["EMA äº¤å‰", "MACD è¶‹åŠ¿", "æˆäº¤é‡çªç ´"],
        "risk": "ä¸­ç­‰",
        "win_rate": "62%",
        "avg_return": "+4.2%/trade",
    },
    "mean_reversion": {
        "name": "ğŸ”„ å‡å€¼å›å½’ Mean Reversion",
        "desc": "ä»·æ ¼åç¦»å‡å€¼æ—¶åå‘äº¤æ˜“ã€‚Buy low, sell high when price deviates from mean.",
        "signals": ["å¸ƒæ—å¸¦", "RSI è¶…ä¹°/è¶…å–", "VWAP åç¦»"],
        "risk": "ä½-ä¸­",
        "win_rate": "71%",
        "avg_return": "+2.1%/trade",
    },
    "arbitrage": {
        "name": "âš¡ DEX å¥—åˆ© Arbitrage",
        "desc": "è·¨ DEX ä»·å·®å¥—åˆ©ã€‚Exploit price differences across Cetus, DeepBook, Turbos etc.",
        "signals": ["ä»·å·®ç›‘æ§", "Gas ä¼˜åŒ–", "åŸå­äº¤æ˜“"],
        "risk": "ä½",
        "win_rate": "89%",
        "avg_return": "+0.3%/trade",
    }
}

strategy_state = {
    "active": "trend",
    "enabled": {"trend": True, "mean_reversion": False, "arbitrage": False},
    "total_trades": 47,
    "win_count": 31,
    "pnl": +12.6,
    "last_signal": "EMA 12/26 é‡‘å‰ï¼Œå»ºè®®åŠ ä»“ SUI",
    "last_signal_time": "10:15",
}

# ==================== Walrus æ—¥å¿— ====================
WALRUS_BLOBS = [
    {"id": "Dq4wG3x...", "time": "02-09 22:00", "type": "strategy_snapshot", "size": "2.1KB"},
    {"id": "Fx8kL2m...", "time": "02-09 18:30", "type": "trade_log", "size": "1.4KB"},
    {"id": "Ap3nR7w...", "time": "02-09 15:00", "type": "risk_report", "size": "3.2KB"},
]

# ==================== æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆ ====================
def gen_whale_data():
    now = datetime.now(HK_TZ)
    whales = []
    addrs = [
        ("0x7d20...3f8a", "0x91ab...c4d2"), ("0xf4e1...8b73", "0x2c9d...a1f6"),
        ("0xa823...d9e1", "0x5f7b...2c84"), ("0x1b4e...f723", "0xd8a6...9e51"),
        ("0x6c3f...b248", "0x3e7a...d195"), ("0xe912...4a6d", "0x8b5c...f3e7"),
    ]
    types = ["ğŸŸ¢ ä¹°å…¥ Buy", "ğŸ”´ å–å‡º Sell", "ğŸ”µ è½¬è´¦ Transfer"]
    tokens = ["SUI", "SUI", "SUI", "USDC", "SUI", "CETUS"]
    for i in range(6):
        t = now - timedelta(minutes=random.randint(2, 180))
        amt = random.choice([10_000, 25_000, 50_000, 100_000, 150_000, 280_000, 500_000])
        fr, to = addrs[i]
        typ = random.choice(types)
        tok = tokens[i]
        usd = amt * 3.82 if tok == "SUI" else amt
        whales.append({
            "time": t.strftime("%H:%M"),
            "amount": f"{amt:,.0f} {tok}",
            "usd": f"${usd:,.0f}",
            "from": fr, "to": to,
            "type": typ,
        })
    whales.sort(key=lambda x: x["time"], reverse=True)
    return whales

def gen_pool_data():
    pools = [
        {"pair": "SUI/USDC", "tvl": "$12.8M", "vol": "$4.2M", "apr": "18.5%", "age": "2h ago", "dex": "Cetus"},
        {"pair": "NAVX/SUI", "tvl": "$890K", "vol": "$320K", "apr": "45.2%", "age": "5h ago", "dex": "Cetus"},
        {"pair": "CETUS/USDC", "tvl": "$3.2M", "vol": "$1.1M", "apr": "22.8%", "age": "8h ago", "dex": "Cetus"},
        {"pair": "HASUI/SUI", "tvl": "$6.5M", "vol": "$2.8M", "apr": "12.3%", "age": "12h ago", "dex": "Cetus"},
        {"pair": "WETH/USDC", "tvl": "$5.1M", "vol": "$1.9M", "apr": "15.7%", "age": "1d ago", "dex": "Cetus"},
        {"pair": "TURBOS/SUI", "tvl": "$420K", "vol": "$95K", "apr": "68.4%", "age": "1d ago", "dex": "Turbos"},
    ]
    return pools

def gen_portfolio_data(sui_balance: float):
    holdings = [
        {"token": "SUI", "amount": sui_balance, "cost": 2.85, "price": 3.82, "icon": "ğŸŸ¦"},
        {"token": "USDC", "amount": 1250.00, "cost": 1.00, "price": 1.00, "icon": "ğŸ’µ"},
        {"token": "CETUS", "amount": 8500, "cost": 0.082, "price": 0.0897, "icon": "ğŸ‹"},
        {"token": "NAVX", "amount": 3200, "cost": 0.21, "price": 0.248, "icon": "ğŸ§­"},
        {"token": "HASUI", "amount": 450, "cost": 3.75, "price": 3.91, "icon": "ğŸ’"},
    ]
    return holdings

def gen_signals():
    now = datetime.now(HK_TZ)
    signals = [
        {
            "icon": "ğŸŸ¢", "type": "ä¹°å…¥ BUY", "pair": "SUI/USDC",
            "reason": "EMA 12/26 é‡‘å‰ç¡®è®¤ï¼ŒMACD æŸ±çŠ¶å›¾è½¬æ­£",
            "target": "$4.20", "stop": "$3.45", "confidence": "85%",
            "time": (now - timedelta(minutes=12)).strftime("%H:%M"),
        },
        {
            "icon": "ğŸ”´", "type": "å–å‡º SELL", "pair": "CETUS/USDC",
            "reason": "RSI(14) = 78 è¶…ä¹°åŒºï¼Œå¸ƒæ—å¸¦ä¸Šè½¨å‹åŠ›",
            "target": "$0.072", "stop": "$0.095", "confidence": "72%",
            "time": (now - timedelta(minutes=45)).strftime("%H:%M"),
        },
        {
            "icon": "ğŸŸ¢", "type": "ä¹°å…¥ BUY", "pair": "NAVX/SUI",
            "reason": "çªç ´ä¸‹é™è¶‹åŠ¿çº¿ï¼Œæˆäº¤é‡æ”¾å¤§ 3.2x",
            "target": "0.068 SUI", "stop": "0.052 SUI", "confidence": "78%",
            "time": (now - timedelta(hours=1, minutes=20)).strftime("%H:%M"),
        },
        {
            "icon": "ğŸŸ¡", "type": "è§‚æœ› HOLD", "pair": "WETH/USDC",
            "reason": "æ¨ªç›˜æ•´ç†ä¸­ï¼Œç­‰å¾…æ–¹å‘çªç ´",
            "target": "-", "stop": "-", "confidence": "55%",
            "time": (now - timedelta(hours=2)).strftime("%H:%M"),
        },
        {
            "icon": "ğŸŸ¢", "type": "ä¹°å…¥ BUY", "pair": "HASUI/SUI",
            "reason": "è´¨æŠ¼æ”¶ç›Šç‡ä¸Šå‡ï¼Œåè®® TVL å¢é•¿ 15%",
            "target": "1.05 SUI", "stop": "0.98 SUI", "confidence": "80%",
            "time": (now - timedelta(hours=3)).strftime("%H:%M"),
        },
    ]
    return signals

def gen_token_safety(coin_type: str, metadata: dict):
    """Generate mock safety check for a token"""
    # Well-known safe tokens
    safe_tokens = ["SUI", "USDC", "USDT", "WETH", "CETUS", "NAVX", "HASUI", "TURBOS"]
    symbol = (metadata or {}).get("symbol", "")
    
    if symbol.upper() in safe_tokens:
        return {
            "rating": "ğŸŸ¢ å®‰å…¨ SAFE",
            "score": random.randint(85, 98),
            "checks": [
                "âœ… åˆçº¦å·²éªŒè¯ Verified Contract",
                "âœ… æµåŠ¨æ€§å……è¶³ Adequate Liquidity",
                "âœ… å‘è¡Œé‡åˆç† Reasonable Supply",
                "âœ… å›¢é˜Ÿå·²çŸ¥ Known Team",
                "âœ… å®¡è®¡é€šè¿‡ Audited",
            ]
        }
    else:
        checks = []
        score = random.randint(30, 70)
        checks.append(random.choice(["âœ… åˆçº¦å·²éªŒè¯", "âš ï¸ åˆçº¦æœªéªŒè¯ Unverified"]))
        checks.append(random.choice(["âœ… æµåŠ¨æ€§å·²é”", "âš ï¸ æµåŠ¨æ€§æœªé” Unlocked LP"]))
        if score > 50:
            checks.append("âœ… å‘è¡Œé‡åˆç†")
        else:
            checks.append("âš ï¸ å‘è¡Œé‡è¿‡å¤§ Excessive Supply")
        checks.append(random.choice(["âœ… æ— æ¶æ„å‡½æ•°", "âš ï¸ å­˜åœ¨å¯ç–‘å‡½æ•° Suspicious Functions"]))
        
        if score >= 60:
            rating = "ğŸŸ¡ æ³¨æ„ CAUTION"
        else:
            rating = "ğŸ”´ å±é™© DANGER"
        return {"rating": rating, "score": score, "checks": checks}

# ==================== é”®ç›˜å¸ƒå±€ ====================
def main_keyboard(lang="cn"):
    """GMGN-style main menu â€” åŒè¯­æŒ‰é’®"""
    # ç”¨ lang ç›´æ¥å–æ–‡æœ¬çš„ helper
    def _t(key):
        entry = TEXTS.get(key, {})
        return entry.get(lang, entry.get("cn", key))
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(_t("btn_assets"), callback_data="assets"),
         InlineKeyboardButton(_t("btn_swap"), callback_data="swap_menu")],
        [InlineKeyboardButton(_t("btn_portfolio"), callback_data="portfolio"),
         InlineKeyboardButton(_t("btn_limit"), callback_data="limit")],
        [InlineKeyboardButton(_t("btn_whale"), callback_data="whale"),
         InlineKeyboardButton(_t("btn_pools"), callback_data="pools")],
        [InlineKeyboardButton(_t("btn_signals"), callback_data="signals"),
         InlineKeyboardButton(_t("btn_strategy"), callback_data="strategy")],
        [InlineKeyboardButton(_t("btn_mint"), callback_data="sl_mint"),
         InlineKeyboardButton(_t("btn_yield"), callback_data="sl_yield")],
        [InlineKeyboardButton(_t("btn_social"), callback_data="social"),
         InlineKeyboardButton(_t("btn_walrus"), callback_data="walrus")],
        [InlineKeyboardButton(_t("btn_vault"), callback_data="vault"),
         InlineKeyboardButton(_t("btn_settings"), callback_data="settings")],
        [InlineKeyboardButton(_t("btn_help"), callback_data="help")],
        [InlineKeyboardButton("ğŸ‡¨ğŸ‡³ ä¸­æ–‡" if lang == "en" else "ğŸ‡¬ğŸ‡§ English", callback_data="lang_toggle")],
    ])

def swap_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("SUI â†’ USDC", callback_data="swap_SUI/USDC"),
         InlineKeyboardButton("USDC â†’ SUI", callback_data="swap_USDC/SUI")],
        [InlineKeyboardButton("SUI â†’ WETH", callback_data="swap_SUI/WETH"),
         InlineKeyboardButton("SUI â†’ CETUS", callback_data="swap_SUI/CETUS")],
        [InlineKeyboardButton("SUI â†’ USDT", callback_data="swap_SUI/USDT"),
         InlineKeyboardButton("ğŸ”§ è‡ªå®šä¹‰ Custom", callback_data="swap_custom")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])

def strategy_keyboard():
    s = strategy_state["enabled"]
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(
            f"{'âœ…' if s['trend'] else 'â¬œ'} è¶‹åŠ¿è·Ÿè¸ª",
            callback_data="strat_trend"),
         InlineKeyboardButton(
            f"{'âœ…' if s['mean_reversion'] else 'â¬œ'} å‡å€¼å›å½’",
            callback_data="strat_mean_reversion")],
        [InlineKeyboardButton(
            f"{'âœ…' if s['arbitrage'] else 'â¬œ'} DEX å¥—åˆ©",
            callback_data="strat_arbitrage"),
         InlineKeyboardButton("ğŸ“Š ç­–ç•¥è¯¦æƒ…", callback_data="strat_detail")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])

# ==================== Token æŸ¥è¯¢ ====================
async def send_token_info(message, coin_type: str):
    """Query and display token information + safety check"""
    log_action("token_query", coin_type[:40])
    
    await message.reply_text(T("ğŸ” æ­£åœ¨æŸ¥è¯¢ä»£å¸ä¿¡æ¯...", uid))
    
    metadata = get_coin_metadata(coin_type)
    supply_raw = get_total_supply(coin_type)
    
    if not metadata:
        await message.reply_text(
            f"âŒ *æœªæ‰¾åˆ°ä»£å¸ä¿¡æ¯*\n\n"
            f"CoinType: `{coin_type}`\n\n"
            f"å¯èƒ½åŸå› :\n"
            f"â€¢ åœ°å€æ ¼å¼ä¸æ­£ç¡®\n"
            f"â€¢ è¯¥ä»£å¸ä¸å­˜åœ¨äº {NETWORK}\n"
            f"â€¢ è¯·æ£€æŸ¥æ˜¯å¦ä¸ºå®Œæ•´ CoinType æ ¼å¼\n"
            f"  ä¾‹: `0x2::sui::SUI`",
            parse_mode="Markdown"
        )
        return
    
    name = metadata.get("name", "Unknown")
    symbol = metadata.get("symbol", "???")
    decimals = metadata.get("decimals", 9)
    desc = metadata.get("description", "æ— æè¿°")
    icon_url = metadata.get("iconUrl", "")
    
    # Format supply
    supply_text = "N/A"
    if supply_raw:
        supply_val = int(supply_raw) / (10 ** decimals)
        if supply_val >= 1e12:
            supply_text = f"{supply_val/1e12:.2f}T"
        elif supply_val >= 1e9:
            supply_text = f"{supply_val/1e9:.2f}B"
        elif supply_val >= 1e6:
            supply_text = f"{supply_val/1e6:.2f}M"
        elif supply_val >= 1e3:
            supply_text = f"{supply_val/1e3:.2f}K"
        else:
            supply_text = f"{supply_val:.2f}"
    
    # Safety check
    safety = gen_token_safety(coin_type, metadata)
    safety_lines = "\n".join(f"  {c}" for c in safety["checks"])
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"ğŸ”„ Swap ä¹°å…¥ {symbol}", callback_data=f"swap_SUI/{symbol}" if symbol != "SUI" else "swap_menu"),
         InlineKeyboardButton("ğŸ“Š æŸ¥çœ‹è¯¦æƒ…", callback_data="back")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    text = (
        f"ğŸ” *Token è¯¦æƒ… â€” {name}*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ“› *åç§°:* {name}\n"
        f"ğŸ·ï¸ *ç¬¦å·:* {symbol}\n"
        f"ğŸ”¢ *ç²¾åº¦:* {decimals}\n"
        f"ğŸ“Š *æ€»ä¾›åº”:* {supply_text} {symbol}\n"
    )
    if desc and desc != "æ— æè¿°":
        text += f"ğŸ“ *æè¿°:* {desc[:120]}\n"
    
    text += (
        f"\nğŸ›¡ï¸ *å®‰å…¨æ£€æŸ¥ Safety Check:*\n"
        f"  è¯„çº§: *{safety['rating']}* ({safety['score']}/100)\n"
        f"{safety_lines}\n\n"
        f"ğŸ“‹ *CoinType:*\n`{coin_type}`\n"
    )
    
    await message.reply_text(text, parse_mode="Markdown", reply_markup=kb)

# ==================== å‘½ä»¤å¤„ç†å™¨ ====================
async def cmd_lang(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """è¯­è¨€åˆ‡æ¢å‘½ä»¤"""
    uid = str(update.effective_user.id)
    lang = get_lang(uid)
    await update.message.reply_text(
        t(uid, "lang_choose"),
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ‡¨ğŸ‡³ ä¸­æ–‡", callback_data="lang_cn"),
             InlineKeyboardButton("ğŸ‡¬ğŸ‡§ English", callback_data="lang_en")],
            [InlineKeyboardButton(t(uid, "btn_back"), callback_data="back")],
        ])
    )

async def cmd_refer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹é‚€è¯·é“¾æ¥å’Œç»Ÿè®¡"""
    uid = str(update.effective_user.id)
    lang = get_lang(uid)
    count = get_referral_count(uid)
    link = f"https://t.me/SuiJarvisBot?start=ref_{uid}"
    await update.message.reply_text(
        f"ğŸ”— *{'ä½ çš„é‚€è¯·é“¾æ¥' if lang=='cn' else 'Your Referral Link'}*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ“ `{link}`\n\n"
        f"ğŸ‘¥ {'å·²é‚€è¯·' if lang=='cn' else 'Invited'}: *{count}* {'äºº' if lang=='cn' else 'users'}\n\n"
        f"{'åˆ†äº«é“¾æ¥é‚€è¯·å¥½å‹ï¼Œä¸€èµ·èµšé’±ï¼' if lang=='cn' else 'Share and earn together!'}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton(
                "ğŸ“¤ åˆ†äº« Share" if lang=="cn" else "ğŸ“¤ Share",
                switch_inline_query=f"ğŸ¤– Join me on Sui DeFi Jarvis! The Infinite Money Glitch ğŸš€ {link}")],
            [InlineKeyboardButton(t(uid, "btn_back"), callback_data="back")],
        ])
    )

async def cmd_social(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Social é¢æ¿"""
    uid = str(update.effective_user.id)
    await _send_social_panel(update.message, uid)

async def _send_social_panel(msg, uid: str):
    """ç—…æ¯’ä¼ æ’­/ç¤¾äº¤é¢æ¿"""
    lang = get_lang(uid)
    count = get_referral_count(uid)
    link = f"https://t.me/SuiJarvisBot?start=ref_{uid}"
    leaderboard = get_referral_leaderboard(5)

    # æ’è¡Œæ¦œæ–‡æœ¬
    lb_lines = []
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4ï¸âƒ£", "5ï¸âƒ£"]
    for i, (r_uid, r_count) in enumerate(leaderboard):
        lb_lines.append(f"  {medals[i]} `{r_uid[:8]}...` â€” {r_count} {'äºº' if lang=='cn' else 'refs'}")
    lb_text = "\n".join(lb_lines) if lb_lines else ("  æš‚æ— æ•°æ®" if lang=="cn" else "  No data yet")

    # æ¨¡æ‹Ÿä¼ æ’­æ•°æ®
    impressions = count * random.randint(80, 200)
    clicks = count * random.randint(5, 20)
    conversion = f"{(clicks/max(impressions,1)*100):.1f}%" if impressions > 0 else "0%"

    text = (
        f"{t(uid, 'social_panel_title')}\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ”— *{'é‚€è¯·é“¾æ¥' if lang=='cn' else 'Referral Link'}:*\n"
        f"  `{link}`\n\n"
        f"ğŸ‘¥ *{'ä½ çš„é‚€è¯·' if lang=='cn' else 'Your Referrals'}:* {count} {'äºº' if lang=='cn' else 'users'}\n\n"
        f"ğŸ“Š *{'ä¼ æ’­æ•°æ®' if lang=='cn' else 'Viral Stats'} ({'æ¨¡æ‹Ÿ' if lang=='cn' else 'simulated'}):*\n"
        f"  ğŸ‘€ {'æ›å…‰' if lang=='cn' else 'Impressions'}: {impressions:,}\n"
        f"  ğŸ–±ï¸ {'ç‚¹å‡»' if lang=='cn' else 'Clicks'}: {clicks:,}\n"
        f"  ğŸ“ˆ {'è½¬åŒ–ç‡' if lang=='cn' else 'Conversion'}: {conversion}\n\n"
        f"ğŸ† *{'é‚€è¯·æ’è¡Œæ¦œ' if lang=='cn' else 'Referral Leaderboard'}:*\n"
        f"{lb_text}\n"
    )

    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(
            "ğŸ“£ AI ç”Ÿæˆæ¨æ–‡" if lang=="cn" else "ğŸ“£ AI Tweet",
            callback_data="social_tweet"),
         InlineKeyboardButton(
            "ğŸ”— é‚€è¯·é“¾æ¥" if lang=="cn" else "ğŸ”— Invite Link",
            callback_data="social_invite")],
        [InlineKeyboardButton(
            "ğŸ“¤ åˆ†äº« Share" if lang=="cn" else "ğŸ“¤ Share",
            switch_inline_query=f"ğŸ¤– Sui DeFi Jarvis â€” The Infinite Money Glitch ğŸš€ {link}")],
        [InlineKeyboardButton(t(uid, "btn_back"), callback_data="back")],
    ])

    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    uid = str(user.id)
    name = user.first_name or "Friend"
    lang = get_lang(uid)

    # å¤„ç† referral é“¾æ¥: /start ref_USERID
    if context.args and len(context.args) > 0:
        arg = context.args[0]
        if arg.startswith("ref_"):
            referrer_uid = arg[4:]
            record_referral(uid, referrer_uid)
    
    wallet = get_or_create_wallet(uid)
    balance = get_sui_balance(wallet["address"])
    
    log_action("start", f"{name} (id:{uid})")
    
    _start_msg = (
        f"ğŸ¤– *Sui DeFi Jarvis â€” The Infinite Money Glitch*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"Hey {name}! æˆ‘æ˜¯ Jarvisï¼Œä½ çš„è‡ªä¸» AI DeFi ä»£ç†ã€‚\n"
        f"I'm your autonomous AI DeFi agent on Sui.\n\n"
        f"ğŸ”§ *æŠ€æœ¯æ ˆ Tech Stack:*\n"
        f"â”œ ğŸŒŠ *Sui* â€” Layer 1 åŒºå—é“¾\n"
        f"â”œ ğŸ‹ *Cetus Aggregator* â€” 30+ DEX æœ€ä¼˜è·¯ç”±\n"
        f"â”œ ğŸ˜ *Walrus* â€” å»ä¸­å¿ƒåŒ–æ“ä½œæ—¥å¿—å­˜å‚¨\n"
        f"â”œ ğŸ” *Seal* â€” é“¾ä¸ŠåŠ å¯†ç­–ç•¥æ•°æ®\n"
        f"â”” ğŸ¦ *OpenClaw* â€” AI è¿è¡Œæ—¶ç¯å¢ƒ\n\n"
        f"ğŸ’° *é’±åŒ…å·²å°±ç»ª:*\n"
        f"`{wallet['address'][:16]}...{wallet['address'][-8:]}`\n"
        f"ä½™é¢: *{balance['formatted']}*\n\n"
        f"ğŸ¯ *æ ¸å¿ƒåŠŸèƒ½:*\n"
        f"â€¢ ğŸ” å‘é€åˆçº¦åœ°å€å³æŸ¥ Token ä¿¡æ¯\n"
        f"â€¢ ğŸ”„ è·¨ 30+ DEX æœ€ä¼˜ Swap\n"
        f"â€¢ ğŸ“Š æŒä»“é¢æ¿ + AI äº¤æ˜“ä¿¡å·\n"
        f"â€¢ ğŸ‹ é²¸é±¼è¿½è¸ª + æ–°æ± å­å‘ç°\n"
        f"â€¢ ğŸ·ï¸ é™ä»·å• + ç­–ç•¥å¼•æ“\n\n"
        f"ğŸ‘‡ *é€‰æ‹©æ“ä½œå¼€å§‹:*"
    )
    await update.message.reply_text(
        T(_start_msg, uid),
        parse_mode="Markdown",
        reply_markup=main_keyboard(lang)
    )

async def cmd_wallet(update: Update, context):
    uid = str(update.effective_user.id)
    wallet = get_or_create_wallet(uid)
    balance = get_sui_balance(wallet["address"])
    tokens = get_all_balances(wallet["address"])
    
    token_lines = []
    for t in tokens:
        icon = "ğŸŸ¦" if t["name"] == "SUI" else "ğŸŸ¢"
        token_lines.append(f"  {icon} {t['name']}: *{t['balance']:.4f}*")
    
    token_text = "\n".join(token_lines) if token_lines else "  æš‚æ— æŒä»“"
    
    log_action("wallet", balance["formatted"])
    
    _wallet_msg = (
        f"ğŸ‘› *é’±åŒ…ä¿¡æ¯ Wallet*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ“ *åœ°å€ Address:*\n"
        f"`{wallet['address']}`\n\n"
        f"ğŸŒ ç½‘ç»œ: Sui {NETWORK.capitalize()}\n"
        f"ğŸ“¦ æ¨¡å¼: {'Demo (å…±äº« Testnet)' if wallet.get('mode')=='demo' else 'Personal'}\n\n"
        f"ğŸ’° *èµ„äº§ Assets:*\n"
        f"{token_text}\n\n"
        f"ğŸ”— [æŸ¥çœ‹æµè§ˆå™¨ Explorer](https://suiscan.xyz/{NETWORK}/account/{wallet['address']})"
    )
    await update.message.reply_text(
        T(_wallet_msg, uid),
        parse_mode="Markdown",
        disable_web_page_preview=True
    )

async def cmd_balance(update: Update, context):
    uid = str(update.effective_user.id)
    wallet = get_or_create_wallet(uid)
    balance = get_sui_balance(wallet["address"])
    log_action("balance", balance["formatted"])
    await update.message.reply_text(
        f"ğŸ’° *{balance['formatted']}*\n"
        f"ğŸ“ `{wallet['address'][:16]}...`\n"
        f"ğŸŒ Sui {NETWORK.capitalize()}",
        parse_mode="Markdown"
    )

async def cmd_swap(update: Update, context):
    log_action("swap_menu")
    await update.message.reply_text(
        "ğŸ”„ *Swap äº¤æ˜“ â€” Cetus Aggregator*\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ‹ è·¯ç”±è¦†ç›– 30+ DEX:\n"
        "Cetus Â· DeepBook Â· Turbos Â· Aftermath\n"
        "FlowX Â· KriyaDEX Â· BlueFin Â· Haedal...\n\n"
        "é€‰æ‹©äº¤æ˜“å¯¹ï¼Œè·å–æœ€ä¼˜æŠ¥ä»· ğŸ‘‡",
        parse_mode="Markdown",
        reply_markup=swap_keyboard()
    )

async def cmd_strategy(update: Update, context):
    log_action("strategy")
    await _send_strategy_panel(update.message)

async def cmd_logs(update: Update, context):
    log_action("view_logs")
    await _send_logs_panel(update.message)

async def cmd_whale(update: Update, context):
    log_action("whale")
    await _send_whale_panel(update.message)

async def cmd_pools(update: Update, context):
    log_action("pools")
    await _send_pools_panel(update.message)

async def cmd_portfolio(update: Update, context):
    uid = str(update.effective_user.id)
    log_action("portfolio")
    await _send_portfolio_panel(update.message, uid)

async def cmd_limit(update: Update, context):
    log_action("limit")
    await _send_limit_panel(update.message, str(update.effective_user.id), context)

async def cmd_signals(update: Update, context):
    log_action("signals")
    await _send_signals_panel(update.message)

async def cmd_help(update: Update, context):
    await update.message.reply_text(
        "â“ *Sui DeFi Jarvis â€” ä½¿ç”¨æŒ‡å—*\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "*ğŸ“± å‘½ä»¤ Commands:*\n"
        "â”œ /start â€” ä¸»èœå• Main Menu\n"
        "â”œ /wallet â€” é’±åŒ…ä¿¡æ¯ Wallet Info\n"
        "â”œ /balance â€” æŸ¥çœ‹ä½™é¢ Check Balance\n"
        "â”œ /swap â€” ä»£å¸äº¤æ¢ Token Swap\n"
        "â”œ /portfolio â€” æŒä»“é¢æ¿ Portfolio\n"
        "â”œ /limit â€” é™ä»·å• Limit Orders\n"
        "â”œ /whale â€” é²¸é±¼è¿½è¸ª Whale Tracker\n"
        "â”œ /pools â€” æ–°æ± å­ New Pools\n"
        "â”œ /signals â€” AI äº¤æ˜“ä¿¡å·\n"
        "â”œ /strategy â€” AI ç­–ç•¥ç®¡ç†\n"
        "â”œ /mint â€” é“¸é€  JarvisUSD (StableLayer)\n"
        "â”œ /burn â€” èµå› JarvisUSD\n"
        "â”œ /yield â€” æŸ¥çœ‹æ”¶ç›Š Yield\n"
        "â”œ /stablelayer â€” StableLayer é¢æ¿\n"
        "â”œ /logs â€” æ“ä½œæ—¥å¿— Operation Logs\n"
        "â”” /help â€” å¸®åŠ© Help\n\n"
        "*ğŸ” Token æŸ¥è¯¢:*\n"
        "ç›´æ¥å‘é€åˆçº¦åœ°å€æˆ– CoinType å³å¯æŸ¥è¯¢ï¼š\n"
        "â€¢ `0x2::sui::SUI`\n"
        "â€¢ `0xdba34672e...::coin::COIN`\n\n"
        "*ğŸ’¬ è‡ªç„¶è¯­è¨€ Natural Language:*\n"
        "â€¢ \"ä½™é¢å¤šå°‘\" / \"check balance\"\n"
        "â€¢ \"å¸®æˆ‘æ¢ 10 SUI åˆ° USDC\"\n"
        "â€¢ \"é²¸é±¼\" / \"whale\"\n"
        "â€¢ \"æ–°æ± å­\" / \"pools\"\n"
        "â€¢ \"ä¿¡å·\" / \"signals\"\n\n"
        "*ğŸ”§ æŠ€æœ¯æ¶æ„:*\n"
        "â€¢ ğŸŒŠ Sui â€” Move æ™ºèƒ½åˆçº¦\n"
        "â€¢ ğŸ‹ Cetus â€” èšåˆå™¨æœ€ä¼˜è·¯ç”±\n"
        "â€¢ ğŸ˜ Walrus â€” å»ä¸­å¿ƒåŒ–æ—¥å¿—\n"
        "â€¢ ğŸ” Seal â€” ç­–ç•¥æ•°æ®åŠ å¯†\n"
        "â€¢ ğŸ¦ OpenClaw â€” AI Agent è¿è¡Œæ—¶\n\n"
        f"ğŸ“¦ åˆçº¦: `{DEPLOYED_PACKAGE[:20]}...`\n"
        f"ğŸŒ ç½‘ç»œ: Sui {NETWORK.capitalize()}\n\n"
        "*Powered by OpenClaw Ã— Sui Ã— Cetus Ã— Walrus*",
        parse_mode="Markdown"
    )

# ==================== é¢æ¿æ¸²æŸ“å‡½æ•° ====================
async def _send_strategy_panel(msg):
    s = strategy_state
    active = STRATEGIES[s["active"]]
    wr = s["win_count"] / s["total_trades"] * 100 if s["total_trades"] > 0 else 0
    
    await msg.reply_text(
        f"ğŸ¤– *AI ç­–ç•¥å¼•æ“ Strategy Engine*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ¯ *å½“å‰ç­–ç•¥: {active['name']}*\n"
        f"  {active['desc']}\n\n"
        f"ğŸ“Š *ä¿¡å·æº Signals:*\n"
        f"  {'  Â·  '.join(active['signals'])}\n\n"
        f"ğŸ“ˆ *ç»©æ•ˆ Performance:*\n"
        f"  â”œ æ€»äº¤æ˜“: {s['total_trades']} ç¬”\n"
        f"  â”œ èƒœç‡: {wr:.0f}% ({s['win_count']}W/{s['total_trades']-s['win_count']}L)\n"
        f"  â”œ ç´¯è®¡ç›ˆäº: *{'+' if s['pnl']>=0 else ''}{s['pnl']:.1f} SUI*\n"
        f"  â”” å¹³å‡å›æŠ¥: {active['avg_return']}\n\n"
        f"ğŸ”” *æœ€æ–°ä¿¡å·:*\n"
        f"  ğŸ’¡ [{s['last_signal_time']}] {s['last_signal']}\n\n"
        f"âš ï¸ é£é™©ç­‰çº§: {active['risk']}\n\n"
        f"ğŸ‘‡ ç‚¹å‡»åˆ‡æ¢ç­–ç•¥:",
        parse_mode="Markdown",
        reply_markup=strategy_keyboard()
    )

async def _send_logs_panel(msg):
    logs = _load_logs()
    recent = logs[-8:]
    
    if not recent:
        await msg.reply_text("ğŸ“‹ æš‚æ— æ“ä½œæ—¥å¿—ã€‚è¯•è¯• /start æˆ– /swapï¼")
        return
    
    lines = []
    for l in recent:
        t = l["time"][5:16].replace("T", " ")
        emoji = {"start": "ğŸš€", "balance": "ğŸ’°", "swap_menu": "ğŸ”„", "swap_quote": "ğŸ“Š",
                 "wallet": "ğŸ‘›", "strategy": "ğŸ¤–", "wallet_auto_create": "ğŸ†•",
                 "view_logs": "ğŸ“‹", "whale": "ğŸ‹", "pools": "ğŸŒ±", "signals": "ğŸ“¢",
                 "portfolio": "ğŸ“Š", "limit": "ğŸ·ï¸", "token_query": "ğŸ”"}.get(l["action"], "ğŸ“")
        lines.append(f"  {emoji} `{t}` *{l['action']}* {l.get('detail','')[:40]}")
    
    walrus_section = "\n\nğŸ˜ *Walrus é“¾ä¸Šæ—¥å¿—:*\n"
    for b in WALRUS_BLOBS[-3:]:
        walrus_section += f"  ğŸ“¦ `{b['id']}` ({b['time']}) {b['type']} [{b['size']}]\n"
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ˜ ä¸Šä¼ åˆ° Walrus", callback_data="walrus_upload"),
         InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="refresh_logs")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    await msg.reply_text(
        f"ğŸ“‹ *æ“ä½œæ—¥å¿— Operation Logs*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"*æœ€è¿‘æ“ä½œ:*\n" + "\n".join(lines) +
        walrus_section +
        f"\nğŸ“Š æ€»è®°å½•: {len(logs)} æ¡ | é“¾ä¸Š: {len(WALRUS_BLOBS)} æ¡",
        parse_mode="Markdown",
        reply_markup=kb
    )

async def _send_dashboard(msg, uid):
    wallet = get_or_create_wallet(uid)
    balance = get_sui_balance(wallet["address"])
    s = strategy_state
    wr = s["win_count"] / s["total_trades"] * 100 if s["total_trades"] > 0 else 0
    active = STRATEGIES[s["active"]]
    
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    await msg.reply_text(
        f"ğŸ“Š *Jarvis ä»ªè¡¨ç›˜ Dashboard*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT | Sui {NETWORK.capitalize()}\n\n"
        f"ğŸ’° *èµ„äº§ Assets:*\n"
        f"  ğŸŸ¦ SUI: *{balance['formatted']}*\n"
        f"  ğŸ’µ ä¼°å€¼: ~${balance['sui'] * 3.82:.2f}\n\n"
        f"ğŸ¤– *ç­–ç•¥ Strategy:*\n"
        f"  ğŸ“ˆ {active['name']}\n"
        f"  â”œ èƒœç‡: {wr:.0f}% | äº¤æ˜“: {s['total_trades']}ç¬”\n"
        f"  â”” P&L: *{'+' if s['pnl']>=0 else ''}{s['pnl']:.1f} SUI*\n\n"
        f"ğŸ”” *æœ€æ–°ä¿¡å·:*\n"
        f"  ğŸ’¡ {s['last_signal']}\n\n"
        f"ğŸ˜ *Walrus:* {len(WALRUS_BLOBS)} logs on-chain\n"
        f"ğŸ” *Vault:* `{DEPLOYED_PACKAGE[:16]}...`\n\n"
        f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        f"_Powered by OpenClaw Ã— Sui Ã— Cetus Ã— Walrus_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="dashboard"),
             InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")],
        ])
    )

async def _send_whale_panel(msg):
    whales = gen_whale_data()
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    lines = []
    for w in whales:
        lines.append(
            f"  {w['type']}\n"
            f"    ğŸ’° {w['amount']} ({w['usd']})\n"
            f"    ğŸ“ {w['from']} â†’ {w['to']}\n"
            f"    â° {w['time']}"
        )
    
    text = (
        f"ğŸ‹ *é²¸é±¼è¿½è¸ª Whale Tracker*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT | ç­›é€‰: >10K SUI\n\n"
        + "\n\n".join(lines) +
        f"\n\nğŸ“Š æœ€è¿‘ 3h å¤§é¢äº¤æ˜“: {len(whales)} ç¬”\n"
        f"ğŸ’° æ€»æµåŠ¨: ${sum(random.randint(50000, 500000) for _ in whales):,.0f}\n\n"
        f"_æ•°æ®æ¯ 5 åˆ†é’Ÿåˆ·æ–° | å®æ—¶ç›‘æ§ Sui ç½‘ç»œ_"
    )
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="whale"),
         InlineKeyboardButton("ğŸ“Š ç»Ÿè®¡åˆ†æ", callback_data="whale_stats")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_pools_panel(msg):
    pools = gen_pool_data()
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    lines = []
    for i, p in enumerate(pools, 1):
        lines.append(
            f"  *{i}. {p['pair']}* ({p['dex']})\n"
            f"    ğŸ’§ TVL: {p['tvl']} | ğŸ“ˆ Vol: {p['vol']}\n"
            f"    ğŸ”¥ APR: *{p['apr']}* | ğŸ• {p['age']}"
        )
    
    text = (
        f"ğŸŒ± *æ–°æ± å­ New Pools â€” Sui DEX*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT | Cetus Â· Turbos Â· DeepBook\n\n"
        + "\n\n".join(lines) +
        f"\n\nğŸ“Š è¿‡å» 24h æ–°ä¸Šçº¿: {len(pools)} ä¸ªæ± å­\n\n"
        f"_ğŸ’¡ é«˜ APR ä¼´éšé«˜é£é™©ï¼Œè¯·æ³¨æ„æ— å¸¸æŸå¤±_"
    )
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="pools"),
         InlineKeyboardButton("ğŸ“Š æŒ‰ APR æ’åº", callback_data="pools_apr")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_portfolio_panel(msg, uid):
    wallet = get_or_create_wallet(uid)
    balance = get_sui_balance(wallet["address"])
    holdings = gen_portfolio_data(balance["sui"])
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    lines = []
    total_value = 0
    total_cost = 0
    for h in holdings:
        val = h["amount"] * h["price"]
        cost = h["amount"] * h["cost"]
        pnl_pct = ((h["price"] - h["cost"]) / h["cost"] * 100) if h["cost"] > 0 else 0
        pnl_icon = "ğŸŸ¢" if pnl_pct >= 0 else "ğŸ”´"
        total_value += val
        total_cost += cost
        lines.append(
            f"  {h['icon']} *{h['token']}*\n"
            f"    æ•°é‡: {h['amount']:,.2f} | ä»·å€¼: ${val:,.2f}\n"
            f"    æˆæœ¬: ${h['cost']:.4f} â†’ å½“å‰: ${h['price']:.4f}\n"
            f"    {pnl_icon} P&L: *{'+' if pnl_pct>=0 else ''}{pnl_pct:.1f}%*"
        )
    
    total_pnl = total_value - total_cost
    total_pnl_pct = (total_pnl / total_cost * 100) if total_cost > 0 else 0
    pnl_icon = "ğŸŸ¢" if total_pnl >= 0 else "ğŸ”´"
    
    text = (
        f"ğŸ“Š *æŒä»“é¢æ¿ Portfolio*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT\n\n"
        + "\n\n".join(lines) +
        f"\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ’¼ *æ€»èµ„äº§:* ${total_value:,.2f}\n"
        f"ğŸ’° *æ€»æˆæœ¬:* ${total_cost:,.2f}\n"
        f"{pnl_icon} *æ€»ç›ˆäº:* {'+' if total_pnl>=0 else ''}${total_pnl:,.2f} ({'+' if total_pnl_pct>=0 else ''}{total_pnl_pct:.1f}%)\n\n"
        f"_SUI ä½™é¢ä¸ºå®æ—¶é“¾ä¸Šæ•°æ®ï¼Œå…¶ä½™ä¸º Demo æ¨¡æ‹Ÿ_"
    )
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="portfolio"),
         InlineKeyboardButton("ğŸ“ˆ æ”¶ç›Šæ›²çº¿", callback_data="portfolio_chart")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_limit_panel(msg, uid, context=None):
    orders = load_limit_orders()
    user_orders = [o for o in orders if o.get("uid") == uid]
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    if user_orders:
        lines = []
        for i, o in enumerate(user_orders):
            status = "â³ ç­‰å¾…" if o.get("status") == "pending" else "âœ… å®Œæˆ"
            direction = "ğŸŸ¢ ä¹°å…¥" if o.get("direction") == "buy" else "ğŸ”´ å–å‡º"
            lines.append(
                f"  *#{o.get('id', i+1)}* {direction}\n"
                f"    äº¤æ˜“å¯¹: {o.get('pair', 'SUI/USDC')}\n"
                f"    ç›®æ ‡ä»·: ${o.get('target_price', 0):.4f}\n"
                f"    æ•°é‡: {o.get('amount', 0)} {o.get('pair', 'SUI/USDC').split('/')[0]}\n"
                f"    çŠ¶æ€: {status}\n"
                f"    åˆ›å»º: {o.get('created', 'N/A')[:16]}"
            )
        order_text = "\n\n".join(lines)
    else:
        order_text = "  æš‚æ— æŒ‚å• No active orders"
    
    text = (
        f"ğŸ·ï¸ *é™ä»·å• Limit Orders*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT\n\n"
        f"*å½“å‰æŒ‚å•:*\n"
        f"{order_text}\n\n"
        f"*åˆ›å»ºæ–°é™ä»·å•:*\n"
        f"å‘é€æ ¼å¼:\n"
        f"`limit buy SUI/USDC 3.50 100`\n"
        f"`limit sell SUI/USDC 4.20 50`\n\n"
        f"_æ ¼å¼: limit [buy/sell] [äº¤æ˜“å¯¹] [ç›®æ ‡ä»·] [æ•°é‡]_"
    )
    
    buttons = [[InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="limit")]]
    if user_orders:
        buttons.append([InlineKeyboardButton("âŒ å–æ¶ˆå…¨éƒ¨æŒ‚å•", callback_data="limit_cancel_all")])
    buttons.append([InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")])
    
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(buttons))

async def _send_signals_panel(msg):
    signals = gen_signals()
    now = datetime.now(HK_TZ).strftime("%H:%M")
    
    lines = []
    for s in signals:
        lines.append(
            f"  {s['icon']} *{s['type']}* â€” {s['pair']}\n"
            f"    ğŸ“ {s['reason']}\n"
            f"    ğŸ¯ ç›®æ ‡: {s['target']} | æ­¢æŸ: {s['stop']}\n"
            f"    ğŸ“Š ç½®ä¿¡åº¦: {s['confidence']} | â° {s['time']}"
        )
    
    text = (
        f"ğŸ“¢ *AI äº¤æ˜“ä¿¡å· Trading Signals*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT | å¼•æ“: Jarvis AI v2.0\n\n"
        + "\n\n".join(lines) +
        f"\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ“Š ä»Šæ—¥ä¿¡å·: {len(signals)} ä¸ª | èƒœç‡: 73%\n"
        f"ğŸ¤– åŸºäº: EMA Â· RSI Â· MACD Â· æˆäº¤é‡ Â· é“¾ä¸Šæ•°æ®\n\n"
        f"âš ï¸ _ä¿¡å·ä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®_"
    )
    
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°ä¿¡å·", callback_data="signals"),
         InlineKeyboardButton("âš™ï¸ ä¿¡å·è®¾ç½®", callback_data="signals_settings")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

# ==================== StableLayer æ¨¡æ‹Ÿæ•°æ® ====================
STABLELAYER_DATA = {
    "brand_coin": "JarvisUSD",
    "underlying": "USDC",
    "total_supply": 285_420.50,
    "total_reserve": 285_420.50,
    "apy": 4.2,
    "protocol": "Bucket Savings Pool",
    "contract": "0xstablelayer::jarvis_usd::JARVISUSD",
}

# ç”¨æˆ· JarvisUSD ä½™é¢ï¼ˆæ¨¡æ‹Ÿï¼‰
_jarvis_balances: dict[str, float] = {}

def _get_jarvis_balance(uid: str) -> float:
    return _jarvis_balances.get(uid, 0.0)

def _add_jarvis_balance(uid: str, amount: float):
    _jarvis_balances[uid] = _jarvis_balances.get(uid, 0.0) + amount

def _sub_jarvis_balance(uid: str, amount: float) -> bool:
    cur = _jarvis_balances.get(uid, 0.0)
    if cur < amount:
        return False
    _jarvis_balances[uid] = cur - amount
    return True

# ==================== StableLayer é¢æ¿ ====================
async def _send_stablelayer_panel(msg):
    d = STABLELAYER_DATA
    now = datetime.now(HK_TZ).strftime("%H:%M")
    text = (
        f"ğŸ¦ *StableLayer â€” Stablecoin-as-a-Service*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° {now} HKT\n\n"
        f"ğŸ’ *{d['brand_coin']}* â€” ç”± StableLayer é©±åŠ¨çš„å“ç‰Œç¨³å®šå¸\n"
        f"å­˜å…¥ USDCï¼Œè‡ªåŠ¨ç”Ÿæ¯ï¼Œéšæ—¶èµå›\n\n"
        f"ğŸ“Š *åè®®æ•°æ®:*\n"
        f"  â”œ æ€»ä¾›åº”é‡: *{d['total_supply']:,.2f} {d['brand_coin']}*\n"
        f"  â”œ åº•å±‚å‚¨å¤‡: *{d['total_reserve']:,.2f} USDC*\n"
        f"  â”œ å½“å‰ APY: *{d['apy']}%*\n"
        f"  â”” åº•å±‚åè®®: {d['protocol']} + è‡ªåŠ¨å¤åˆ©\n\n"
        f"ğŸ”— åˆçº¦: `{d['contract']}`\n\n"
        f"_Powered by StableLayer (stablelayer.site)_"
    )
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ’ Mint", callback_data="sl_mint"),
         InlineKeyboardButton("ğŸ”¥ Burn", callback_data="sl_burn")],
        [InlineKeyboardButton("ğŸ“ˆ æŸ¥çœ‹æ”¶ç›Š", callback_data="sl_yield"),
         InlineKeyboardButton("ğŸ“„ æ–‡æ¡£", url="https://docs.stablelayer.site/")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_mint_panel(msg, uid=None):
    d = STABLELAYER_DATA
    text = (
        f"ğŸ’ *é“¸é€  JarvisUSD â€” Mint*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ¦ *StableLayer å“ç‰Œç¨³å®šå¸*\n"
        f"å­˜å…¥ USDC â†’ é“¸é€ ç­‰é¢ JarvisUSD\n"
        f"åº•å±‚ USDC è‡ªåŠ¨è¿›å…¥ Bucket Savings Pool ç”Ÿæ¯\n\n"
        f"ğŸ“ˆ å½“å‰ APY: *{d['apy']}%*\n"
        f"ğŸ’° 1 USDC = 1 JarvisUSD (1:1)\n\n"
        f"é€‰æ‹©é“¸é€ é‡‘é¢ ğŸ‘‡"
    )
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("10 USDC", callback_data="sl_mint_10"),
         InlineKeyboardButton("50 USDC", callback_data="sl_mint_50"),
         InlineKeyboardButton("100 USDC", callback_data="sl_mint_100")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="sl_panel")],
    ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _exec_mint(msg, uid: str, amount: float):
    d = STABLELAYER_DATA
    _add_jarvis_balance(uid, amount)
    tx_hash = hashlib.sha256(f"mint{uid}{amount}{time.time()}".encode()).hexdigest()[:16]
    log_action("stablelayer_mint", f"uid:{uid} amount:{amount}")

    new_bal = _get_jarvis_balance(uid)
    text = (
        f"âœ… *é“¸é€ æˆåŠŸï¼ Mint Complete*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ“¥ å­˜å…¥: *{amount:.2f} USDC*\n"
        f"ğŸ“¤ è·å¾—: *{amount:.2f} JarvisUSD*\n\n"
        f"ğŸ’° JarvisUSD ä½™é¢: *{new_bal:.2f}*\n"
        f"ğŸ“ˆ å½“å‰ APY: *{d['apy']}%*\n"
        f"ğŸ”— åº•å±‚: Bucket Savings Pool + è‡ªåŠ¨å¤åˆ©\n\n"
        f"ğŸ“‹ TX: `0x{tx_hash}...`\n"
        f"â›½ Gas: 0.003 SUI\n\n"
        f"âš ï¸ _Demo æ¨¡å¼ â€” Testnet æ¨¡æ‹Ÿé“¸é€ _\n"
        f"_Powered by StableLayer_"
    )
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ’ ç»§ç»­ Mint", callback_data="sl_mint"),
         InlineKeyboardButton("ğŸ“ˆ æŸ¥çœ‹æ”¶ç›Š", callback_data="sl_yield")],
        [InlineKeyboardButton("ğŸ”™ ä¸»èœå•", callback_data="back")],
    ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_burn_panel(msg, uid: str):
    bal = _get_jarvis_balance(uid)
    text = (
        f"ğŸ”¥ *èµå› JarvisUSD â€” Burn*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"é”€æ¯ JarvisUSD â†’ å–å›ç­‰é¢ USDC\n\n"
        f"ğŸ’° å½“å‰ JarvisUSD ä½™é¢: *{bal:.2f}*\n\n"
    )
    if bal <= 0:
        text += "âš ï¸ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆ Mint\n"
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ’ å» Mint", callback_data="sl_mint")],
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="sl_panel")],
        ])
    else:
        text += "é€‰æ‹©èµå›é‡‘é¢ ğŸ‘‡"
        buttons_row = []
        for amt in [10, 50, 100]:
            if bal >= amt:
                buttons_row.append(InlineKeyboardButton(f"{amt} JUSD", callback_data=f"sl_burn_{amt}"))
        if bal > 0:
            buttons_row.append(InlineKeyboardButton(f"å…¨éƒ¨ {bal:.0f}", callback_data=f"sl_burn_all"))
        kb = InlineKeyboardMarkup([
            buttons_row,
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="sl_panel")],
        ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _exec_burn(msg, uid: str, amount: float):
    bal = _get_jarvis_balance(uid)
    if amount > bal:
        amount = bal
    if amount <= 0:
        await msg.reply_text("âš ï¸ ä½™é¢ä¸è¶³", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="sl_panel")]
        ]))
        return
    _sub_jarvis_balance(uid, amount)
    tx_hash = hashlib.sha256(f"burn{uid}{amount}{time.time()}".encode()).hexdigest()[:16]
    log_action("stablelayer_burn", f"uid:{uid} amount:{amount}")

    new_bal = _get_jarvis_balance(uid)
    text = (
        f"âœ… *èµå›æˆåŠŸï¼ Burn Complete*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ”¥ é”€æ¯: *{amount:.2f} JarvisUSD*\n"
        f"ğŸ“¤ å–å›: *{amount:.2f} USDC*\n\n"
        f"ğŸ’° å‰©ä½™ JarvisUSD: *{new_bal:.2f}*\n"
        f"ğŸ“‹ TX: `0x{tx_hash}...`\n\n"
        f"âš ï¸ _Demo æ¨¡å¼ â€” Testnet æ¨¡æ‹Ÿèµå›_"
    )
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ’ Mint", callback_data="sl_mint"),
         InlineKeyboardButton("ğŸ“ˆ æ”¶ç›Š", callback_data="sl_yield")],
        [InlineKeyboardButton("ğŸ”™ ä¸»èœå•", callback_data="back")],
    ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

async def _send_yield_panel(msg, uid: str):
    d = STABLELAYER_DATA
    bal = _get_jarvis_balance(uid)
    daily_yield = bal * d["apy"] / 100 / 365
    monthly_yield = daily_yield * 30
    yearly_yield = bal * d["apy"] / 100
    # æ¨¡æ‹Ÿç´¯è®¡æ”¶ç›Šï¼ˆå‡è®¾æŒæœ‰ 15 å¤©ï¼‰
    accumulated = daily_yield * 15

    text = (
        f"ğŸ“ˆ *JarvisUSD æ”¶ç›Šé¢æ¿ â€” Yield*\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ’° æŒæœ‰é‡: *{bal:.2f} JarvisUSD*\n\n"
        f"ğŸ“Š *å½“å‰æ”¶ç›Šç‡:*\n"
        f"  â”œ APY: *{d['apy']}%*\n"
        f"  â”œ æ—¥æ”¶ç›Š: ~{daily_yield:.4f} USDC\n"
        f"  â”œ æœˆæ”¶ç›Š: ~{monthly_yield:.2f} USDC\n"
        f"  â”” å¹´æ”¶ç›Š: ~{yearly_yield:.2f} USDC\n\n"
        f"ğŸ’µ *ç´¯è®¡æ”¶ç›Š:* ~{accumulated:.4f} USDC\n\n"
        f"ğŸ”— *åº•å±‚åè®®:*\n"
        f"  Bucket Savings Pool + è‡ªåŠ¨å¤åˆ©\n"
        f"  æ”¶ç›Šæ¥æº: USDC å€Ÿè´·åˆ©æ¯\n\n"
        f"_Powered by StableLayer (stablelayer.site)_"
    )
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ’ Mint æ›´å¤š", callback_data="sl_mint"),
         InlineKeyboardButton("ğŸ”¥ Burn èµå›", callback_data="sl_burn")],
        [InlineKeyboardButton("ğŸ¦ StableLayer", callback_data="sl_panel")],
        [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")],
    ])
    await msg.reply_text(T(text, uid), parse_mode="Markdown", reply_markup=kb)

# ==================== StableLayer å‘½ä»¤å¤„ç†å™¨ ====================
async def cmd_mint(update: Update, context: ContextTypes.DEFAULT_TYPE):
    log_action("mint_menu")
    await _send_mint_panel(update.message, str(update.effective_user.id))

async def cmd_burn(update: Update, context: ContextTypes.DEFAULT_TYPE):
    log_action("burn_menu")
    await _send_burn_panel(update.message, str(update.effective_user.id))

async def cmd_yield(update: Update, context: ContextTypes.DEFAULT_TYPE):
    log_action("yield_view")
    await _send_yield_panel(update.message, str(update.effective_user.id))

async def cmd_stablelayer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    log_action("stablelayer_panel")
    await _send_stablelayer_panel(update.message)

# ==================== å›è°ƒå¤„ç†å™¨ ====================
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data
    uid = str(q.from_user.id)

    if data == "assets":
        wallet = get_or_create_wallet(uid)
        tokens = get_all_balances(wallet["address"])
        balance = get_sui_balance(wallet["address"])
        
        lines = []
        total_usd = 0
        for t in tokens:
            icon = "ğŸŸ¦" if t["name"] == "SUI" else "ğŸŸ¢"
            usd = t["balance"] * (3.82 if t["name"] == "SUI" else 1.0)
            total_usd += usd
            lines.append(f"  {icon} *{t['name']}*: {t['balance']:.4f} (~${usd:.2f})")
        
        token_text = "\n".join(lines) if lines else "  æš‚æ— æŒä»“ No assets"
        
        await q.message.reply_text(
            f"ğŸ’° *èµ„äº§é¢æ¿ Assets*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"{token_text}\n\n"
            f"ğŸ’µ æ€»ä¼°å€¼: *~${total_usd:.2f}*\n\n"
            f"ğŸ“ `{wallet['address'][:16]}...{wallet['address'][-8:]}`\n"
            f"ğŸ”— [æµè§ˆå™¨](https://suiscan.xyz/{NETWORK}/account/{wallet['address']})",
            parse_mode="Markdown",
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”„ åˆ·æ–°ä½™é¢", callback_data="assets"),
                 InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
            ])
        )
        log_action("assets", f"${total_usd:.2f}")

    elif data == "swap_menu":
        await q.message.reply_text(
            "ğŸ”„ *Swap äº¤æ˜“ â€” Cetus Aggregator*\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ğŸ‹ è·¯ç”±è¦†ç›– 30+ DEX:\n"
            "Cetus Â· DeepBook Â· Turbos Â· Aftermath\n"
            "FlowX Â· KriyaDEX Â· BlueFin Â· Haedal...\n\n"
            "é€‰æ‹©äº¤æ˜“å¯¹ï¼Œè·å–æœ€ä¼˜æŠ¥ä»· ğŸ‘‡",
            parse_mode="Markdown",
            reply_markup=swap_keyboard()
        )

    elif data.startswith("swap_") and "/" in data:
        pair = data.replace("swap_", "")
        if pair in SWAP_PAIRS:
            info = SWAP_PAIRS[pair]
            src, dst = pair.split("/")
            amount = 1.0
            out = amount * info["rate"]
            variation = random.uniform(-0.02, 0.02)
            out *= (1 + variation)
            
            log_action("swap_quote", f"{src}â†’{dst} rate:{info['rate']}")
            
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"âœ… ç¡®è®¤äº¤æ˜“ Execute", callback_data=f"exec_{pair}"),
                 InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="swap_menu")],
                [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="swap_menu")],
            ])
            
            await q.message.reply_text(
                f"ğŸ”„ *Swap æŠ¥ä»· Quote*\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                f"ğŸ“¥ *è¾“å…¥ Input:*  {amount} {src}\n"
                f"ğŸ“¤ *è¾“å‡º Output:* {out:.6f} {dst}\n\n"
                f"ğŸ“Š *è·¯ç”±è¯¦æƒ… Route:*\n"
                f"  ğŸ›£ è·¯å¾„: {info['route']}\n"
                f"  ğŸ”€ ç»è¿‡ DEX: {info['dexes']} ä¸ª\n"
                f"  ğŸ’§ æµåŠ¨æ€§æ± : {info['pools']} ä¸ª\n"
                f"  ğŸ“‰ æ»‘ç‚¹ä¿æŠ¤: 0.5%\n"
                f"  â›½ é¢„ä¼° Gas: ~0.005 SUI\n\n"
                f"ğŸ’¡ _æŠ¥ä»·æœ‰æ•ˆæœŸ 30 ç§’_",
                parse_mode="Markdown",
                reply_markup=kb
            )

    elif data.startswith("exec_"):
        pair = data.replace("exec_", "")
        src, dst = pair.split("/")
        tx_hash = hashlib.sha256(f"{pair}{time.time()}".encode()).hexdigest()[:16]
        log_action("swap_execute", f"{src}â†’{dst} tx:{tx_hash}")
        
        await q.message.reply_text(
            f"âœ… *äº¤æ˜“æ¨¡æ‹Ÿæ‰§è¡ŒæˆåŠŸï¼*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"ğŸ”„ {src} â†’ {dst}\n"
            f"ğŸ“‹ TX: `0x{tx_hash}...`\n"
            f"â›½ Gas: 0.004 SUI\n"
            f"â± ç¡®è®¤æ—¶é—´: <1s\n\n"
            f"ğŸ˜ æ—¥å¿—å·²è®°å½•åˆ° Walrus\n\n"
            f"âš ï¸ _Demo æ¨¡å¼ â€” Testnet æ¨¡æ‹Ÿäº¤æ˜“_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”„ ç»§ç»­äº¤æ˜“", callback_data="swap_menu"),
                 InlineKeyboardButton("ğŸ”™ ä¸»èœå•", callback_data="back")],
            ])
        )

    elif data == "swap_custom":
        await q.message.reply_text(
            "ğŸ”§ *è‡ªå®šä¹‰ Swap*\n\n"
            "å‘é€æ ¼å¼ / Send format:\n"
            "`swap 10 SUI USDC`\n\n"
            "æ”¯æŒçš„ä»£å¸: SUI, USDC, USDT, WETH, CETUS",
            parse_mode="Markdown"
        )

    elif data == "strategy":
        await _send_strategy_panel(q.message)

    elif data.startswith("strat_") and data.replace("strat_", "") in STRATEGIES:
        key = data.replace("strat_", "")
        strategy_state["enabled"][key] = not strategy_state["enabled"][key]
        if strategy_state["enabled"][key]:
            strategy_state["active"] = key
        elif strategy_state["active"] == key:
            for k, v in strategy_state["enabled"].items():
                if v:
                    strategy_state["active"] = k
                    break
        log_action("toggle_strategy", f"{key}={strategy_state['enabled'][key]}")
        await _send_strategy_panel(q.message)

    elif data == "strat_detail":
        text = "ğŸ“Š *ç­–ç•¥è¯¦æƒ… Strategy Details*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        for key, info in STRATEGIES.items():
            enabled = "âœ…" if strategy_state["enabled"][key] else "â¬œ"
            active = " ğŸ”¥" if strategy_state["active"] == key else ""
            text += (
                f"{enabled} *{info['name']}*{active}\n"
                f"  {info['desc']}\n"
                f"  ä¿¡å·: {' Â· '.join(info['signals'])}\n"
                f"  èƒœç‡: {info['win_rate']} | å›æŠ¥: {info['avg_return']} | é£é™©: {info['risk']}\n\n"
            )
        await q.message.reply_text(T(text, uid), parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ç­–ç•¥", callback_data="strategy")]
            ]))

    elif data == "dashboard":
        await _send_dashboard(q.message, uid)

    elif data == "whale":
        await _send_whale_panel(q.message)

    elif data == "whale_stats":
        await q.message.reply_text(
            "ğŸ“Š *é²¸é±¼ç»Ÿè®¡ Whale Stats (24h)*\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ğŸŸ¢ *å‡€æµå…¥:* +2,450,000 SUI\n"
            "ğŸ”´ *å‡€æµå‡º:* -1,820,000 SUI\n"
            "ğŸ“Š *å‡€å˜åŒ–:* +630,000 SUI\n\n"
            "ğŸ‹ *æ´»è·ƒé²¸é±¼:* 23 ä¸ªåœ°å€\n"
            "ğŸ’° *æœ€å¤§å•ç¬”:* 500,000 SUI ($1.91M)\n"
            "ğŸ“ˆ *è¶‹åŠ¿:* åå¤š (å‡€ä¹°å…¥)\n\n"
            "_æ•°æ®æ¥æº: Sui é“¾ä¸Šäº¤æ˜“åˆ†æ_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›é²¸é±¼", callback_data="whale")]
            ])
        )

    elif data == "pools":
        await _send_pools_panel(q.message)

    elif data == "pools_apr":
        pools = gen_pool_data()
        pools.sort(key=lambda x: float(x["apr"].replace("%", "")), reverse=True)
        lines = []
        for i, p in enumerate(pools, 1):
            lines.append(f"  {i}. ğŸ”¥ *{p['apr']}* â€” {p['pair']} (TVL: {p['tvl']})")
        await q.message.reply_text(
            f"ğŸŒ± *æ± å­æŒ‰ APR æ’åº*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n" + "\n".join(lines) +
            "\n\nâš ï¸ _é«˜ APR = é«˜é£é™©_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›æ± å­", callback_data="pools")]
            ])
        )

    elif data == "portfolio":
        await _send_portfolio_panel(q.message, uid)

    elif data == "portfolio_chart":
        await q.message.reply_text(
            "ğŸ“ˆ *æ”¶ç›Šæ›²çº¿ Performance Chart (7D)*\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "```\n"
            "  $2,400 â”¤                    â•­â”€\n"
            "  $2,350 â”¤              â•­â”€â”€â”€â”€â”€â•¯\n"
            "  $2,300 â”¤         â•­â”€â”€â”€â”€â•¯\n"
            "  $2,250 â”¤    â•­â”€â”€â”€â”€â•¯\n"
            "  $2,200 â”¤â•­â”€â”€â”€â•¯\n"
            "  $2,150 â”¤â•¯\n"
            "         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "          Mon Tue Wed Thu Fri Sat Sun\n"
            "```\n\n"
            "ğŸ“Š å‘¨æ¶¨å¹…: *+8.2%* | æœ€é«˜: $2,410 | æœ€ä½: $2,150",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›æŒä»“", callback_data="portfolio")]
            ])
        )

    elif data == "limit":
        await _send_limit_panel(q.message, uid)

    elif data == "limit_cancel_all":
        orders = load_limit_orders()
        orders = [o for o in orders if o.get("uid") != uid]
        save_limit_orders(orders)
        log_action("limit_cancel_all", f"uid:{uid}")
        await q.message.reply_text(
            "âœ… *å·²å–æ¶ˆå…¨éƒ¨æŒ‚å•*\n\næ‰€æœ‰é™ä»·å•å·²ç§»é™¤ã€‚",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›é™ä»·å•", callback_data="limit")]
            ])
        )

    elif data.startswith("limit_cancel_"):
        order_id = data.replace("limit_cancel_", "")
        orders = load_limit_orders()
        orders = [o for o in orders if str(o.get("id")) != order_id or o.get("uid") != uid]
        save_limit_orders(orders)
        log_action("limit_cancel", f"order:{order_id}")
        await _send_limit_panel(q.message, uid)

    elif data == "signals":
        await _send_signals_panel(q.message)

    elif data == "signals_settings":
        await q.message.reply_text(
            "âš™ï¸ *ä¿¡å·è®¾ç½® Signal Settings*\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ğŸ“Š *æŠ€æœ¯æŒ‡æ ‡:*\n"
            "  âœ… EMA (12/26)\n"
            "  âœ… RSI (14)\n"
            "  âœ… MACD (12/26/9)\n"
            "  âœ… å¸ƒæ—å¸¦ (20,2)\n"
            "  â¬œ æ–æ³¢é‚£å¥‘å›æ’¤\n\n"
            "ğŸ”” *é€šçŸ¥:*\n"
            "  âœ… ä¹°å…¥ä¿¡å·\n"
            "  âœ… å–å‡ºä¿¡å·\n"
            "  â¬œ è§‚æœ›ä¿¡å·\n\n"
            "â° *åˆ·æ–°é¢‘ç‡:* æ¯ 5 åˆ†é’Ÿ\n\n"
            "_å®Œæ•´ç‰ˆæ”¯æŒè‡ªå®šä¹‰æŒ‡æ ‡å‚æ•°_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ä¿¡å·", callback_data="signals")]
            ])
        )

    elif data == "walrus":
        text = (
            f"ğŸ˜ *Walrus å»ä¸­å¿ƒåŒ–æ—¥å¿—*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"æ¯ç¬”äº¤æ˜“ã€æ¯ä¸ªç­–ç•¥å†³ç­–éƒ½é€æ˜è®°å½•åœ¨ Walrus ä¸Šã€‚\n"
            f"ä¸å¯ç¯¡æ”¹ï¼Œä»»ä½•äººå¯éªŒè¯ã€‚\n\n"
            f"ğŸ“¦ *é“¾ä¸Šæ—¥å¿— On-chain Logs:*\n"
        )
        for b in WALRUS_BLOBS:
            text += f"  ğŸ”— `{b['id']}` | {b['time']} | {b['type']} | {b['size']}\n"
        
        text += (
            f"\nğŸ“Š æ€»è®¡: {len(WALRUS_BLOBS)} blobs | ~6.7KB\n\n"
            f"ğŸ” èšåˆå™¨: `{WALRUS_AGGREGATOR[:40]}...`\n\n"
            f"_æ‰€æœ‰æ“ä½œæ—¥å¿—å®šæœŸä¸Šä¼ ï¼Œç¡®ä¿å®¡è®¡é€æ˜_"
        )
        
        await q.message.reply_text(T(text, uid), parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ˜ ç«‹å³ä¸Šä¼ ", callback_data="walrus_upload"),
                 InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
            ]))

    elif data == "walrus_upload":
        log_action("walrus_upload")
        blob_id = hashlib.sha256(f"walrus{time.time()}".encode()).hexdigest()[:10]
        await q.message.reply_text(
            f"ğŸ˜ *æ—¥å¿—ä¸Šä¼ ä¸­...*\n\n"
            f"âœ… ä¸Šä¼ æˆåŠŸï¼\n"
            f"ğŸ“¦ Blob ID: `{blob_id}...`\n"
            f"ğŸ“Š å¤§å°: {random.randint(1,5)}.{random.randint(0,9)}KB\n"
            f"â± å­˜å‚¨æ—¶é—´: æ°¸ä¹…\n\n"
            f"_æ•°æ®å·²å®‰å…¨å­˜å‚¨åœ¨ Walrus å»ä¸­å¿ƒåŒ–ç½‘ç»œ_",
            parse_mode="Markdown"
        )

    elif data == "vault":
        await q.message.reply_text(
            f"ğŸ” *Vault æ™ºèƒ½åˆçº¦*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"èµ„é‡‘é€šè¿‡ Move åˆçº¦ç®¡ç†ï¼Œå®‰å…¨é€æ˜ã€‚\n\n"
            f"ğŸ“¦ *åˆçº¦ä¿¡æ¯:*\n"
            f"  Package: `{DEPLOYED_PACKAGE}`\n"
            f"  ç½‘ç»œ: Sui {NETWORK.capitalize()}\n\n"
            f"ğŸ›¡ï¸ *å®‰å…¨ç‰¹æ€§:*\n"
            f"  â”œ VaultCap æƒé™æ§åˆ¶\n"
            f"  â”œ å•æ¬¡æå–é™é¢\n"
            f"  â”œ ç´§æ€¥æš‚åœæœºåˆ¶\n"
            f"  â”” æ‰€æœ‰æ“ä½œé“¾ä¸Šå¯æŸ¥\n\n"
            f"ğŸ“Š *åŠŸèƒ½:*\n"
            f"  â€¢ deposit() â€” å­˜å…¥èµ„é‡‘\n"
            f"  â€¢ withdraw() â€” æå–æ”¶ç›Š\n"
            f"  â€¢ emergency\\_pause() â€” ç´§æ€¥æš‚åœ\n\n"
            f"ğŸ”— [æŸ¥çœ‹åˆçº¦](https://suiscan.xyz/{NETWORK}/object/{DEPLOYED_PACKAGE})",
            parse_mode="Markdown",
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")]
            ])
        )

    elif data == "settings":
        await q.message.reply_text(
            "âš™ï¸ *è®¾ç½® Settings*\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"ğŸŒ ç½‘ç»œ: Sui {NETWORK.capitalize()}\n"
            f"ğŸ“¦ æ¨¡å¼: Demo (å…±äº« Testnet é’±åŒ…)\n"
            f"ğŸ”” é€šçŸ¥: å¼€å¯\n"
            f"ğŸ’° æ»‘ç‚¹: 0.5%\n"
            f"â›½ Gas é¢„ç®—: 0.01 SUI\n\n"
            f"_å®Œæ•´ç‰ˆæ”¯æŒè‡ªå®šä¹‰é’±åŒ…å’Œ Mainnet_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")]
            ])
        )

    elif data == "help":
        await q.message.reply_text(
            "â“ ä½¿ç”¨ /help æŸ¥çœ‹å®Œæ•´å¸®åŠ©",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")]
            ])
        )

    elif data == "refresh_logs":
        await _send_logs_panel(q.message)

    # StableLayer callbacks
    elif data == "sl_panel":
        await _send_stablelayer_panel(q.message)

    elif data == "sl_mint":
        await _send_mint_panel(q.message, uid)

    elif data.startswith("sl_mint_"):
        amount = float(data.replace("sl_mint_", ""))
        await _exec_mint(q.message, uid, amount)

    elif data == "sl_burn":
        await _send_burn_panel(q.message, uid)

    elif data.startswith("sl_burn_"):
        val = data.replace("sl_burn_", "")
        if val == "all":
            amount = _get_jarvis_balance(uid)
        else:
            amount = float(val)
        await _exec_burn(q.message, uid, amount)

    elif data == "sl_yield":
        await _send_yield_panel(q.message, uid)

    # ---- åŒè¯­åˆ‡æ¢ ----
    elif data == "lang_toggle":
        cur = get_lang(uid)
        new_lang = "en" if cur == "cn" else "cn"
        set_lang(uid, new_lang)
        label = "ğŸ‡¬ğŸ‡§ Switched to English" if new_lang == "en" else "ğŸ‡¨ğŸ‡³ å·²åˆ‡æ¢ä¸ºä¸­æ–‡"
        await q.message.reply_text(label, reply_markup=main_keyboard(new_lang))

    elif data == "lang_cn":
        set_lang(uid, "cn")
        await q.message.reply_text(
            t(uid, "lang_set_cn"),
            reply_markup=main_keyboard("cn")
        )

    elif data == "lang_en":
        set_lang(uid, "en")
        await q.message.reply_text(
            t(uid, "lang_set_en"),
            reply_markup=main_keyboard("en")
        )

    # ---- Social æ¨¡å— ----
    elif data == "social":
        await _send_social_panel(q.message, uid)

    elif data == "social_tweet":
        lang = get_lang(uid)
        tweet = random.choice(TWEET_TEMPLATES)
        await q.message.reply_text(
            f"ğŸ“£ *{'AI ç”Ÿæˆæ¨æ–‡' if lang=='cn' else 'AI Generated Tweet'}*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"{tweet}\n\n"
            f"{'å¤åˆ¶ä¸Šæ–¹æ–‡æœ¬å‘åˆ° Twitter/X ğŸ¦' if lang=='cn' else 'Copy and post to Twitter/X ğŸ¦'}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”„ æ¢ä¸€æ¡" if lang=="cn" else "ğŸ”„ New Tweet", callback_data="social_tweet")],
                [InlineKeyboardButton(t(uid, "btn_back"), callback_data="social")],
            ])
        )

    elif data == "social_invite":
        lang = get_lang(uid)
        count = get_referral_count(uid)
        link = f"https://t.me/SuiJarvisBot?start=ref_{uid}"
        await q.message.reply_text(
            f"ğŸ”— *{'é‚€è¯·é“¾æ¥' if lang=='cn' else 'Referral Link'}*\n\n"
            f"`{link}`\n\n"
            f"ğŸ‘¥ {'å·²é‚€è¯·' if lang=='cn' else 'Invited'}: *{count}* {'äºº' if lang=='cn' else 'users'}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    "ğŸ“¤ åˆ†äº«" if lang=="cn" else "ğŸ“¤ Share",
                    switch_inline_query=f"ğŸ¤– Sui DeFi Jarvis ğŸš€ {link}")],
                [InlineKeyboardButton(t(uid, "btn_back"), callback_data="social")],
            ])
        )

    elif data == "back":
        lang = get_lang(uid)
        await q.message.reply_text(
            t(uid, "main_greeting"),
            parse_mode="Markdown",
            reply_markup=main_keyboard(lang)
        )

# ==================== è‡ªç„¶è¯­è¨€å¤„ç† ====================
async def nl_handler(update: Update, context):
    text = update.message.text or ""
    text_lower = text.lower().strip()
    
    # 1. æ£€æµ‹ CoinType æ ¼å¼ (åŒ…å« ::)
    coin_type_match = re.search(r'(0x[a-fA-F0-9]{2,}::\w+::\w+)', text)
    if coin_type_match:
        coin_type = coin_type_match.group(1)
        await send_token_info(update.message, coin_type)
        return
    
    # 2. æ£€æµ‹ Sui åœ°å€ (0x å¼€å¤´, >=40å­—ç¬¦çš„åå…­è¿›åˆ¶)
    addr_match = re.search(r'(0x[a-fA-F0-9]{40,})', text)
    if addr_match:
        address = addr_match.group(1)
        # Try as a coin type â€” could be a package address
        await update.message.reply_text(
            f"ğŸ” *æ£€æµ‹åˆ° Sui åœ°å€*\n\n"
            f"`{address[:20]}...{address[-8:]}`\n\n"
            f"ğŸ’¡ å¦‚éœ€æŸ¥è¯¢ä»£å¸ä¿¡æ¯ï¼Œè¯·å‘é€å®Œæ•´ CoinType:\n"
            f"`{address}::module::TOKEN`\n\n"
            f"ğŸ”— [æµè§ˆå™¨æŸ¥çœ‹](https://suiscan.xyz/{NETWORK}/account/{address})",
            parse_mode="Markdown",
            disable_web_page_preview=True,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back")]
            ])
        )
        return
    
    # 3. é™ä»·å•åˆ›å»º
    limit_match = re.match(r'limit\s+(buy|sell)\s+(\w+/\w+)\s+([\d.]+)\s+([\d.]+)', text_lower)
    if limit_match:
        direction = limit_match.group(1)
        pair = limit_match.group(2).upper()
        target_price = float(limit_match.group(3))
        amount = float(limit_match.group(4))
        uid = str(update.effective_user.id)
        
        orders = load_limit_orders()
        order_id = len(orders) + 1
        orders.append({
            "id": order_id,
            "uid": uid,
            "direction": direction,
            "pair": pair,
            "target_price": target_price,
            "amount": amount,
            "status": "pending",
            "created": datetime.now(HK_TZ).isoformat(),
        })
        save_limit_orders(orders)
        log_action("limit_create", f"{direction} {pair} @{target_price} x{amount}")
        
        icon = "ğŸŸ¢" if direction == "buy" else "ğŸ”´"
        await update.message.reply_text(
            f"âœ… *é™ä»·å•å·²åˆ›å»ºï¼*\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"  {icon} *{'ä¹°å…¥ BUY' if direction=='buy' else 'å–å‡º SELL'}*\n"
            f"  äº¤æ˜“å¯¹: {pair}\n"
            f"  ç›®æ ‡ä»·: ${target_price:.4f}\n"
            f"  æ•°é‡: {amount} {pair.split('/')[0]}\n"
            f"  è®¢å•å·: #{order_id}\n\n"
            f"_å½“ä»·æ ¼è§¦åŠç›®æ ‡å°†è‡ªåŠ¨æ‰§è¡Œ_",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“‹ æŸ¥çœ‹æŒ‚å•", callback_data="limit"),
                 InlineKeyboardButton("ğŸ”™ ä¸»èœå•", callback_data="back")]
            ])
        )
        return
    
    # 4. å¸¸è§„è‡ªç„¶è¯­è¨€åŒ¹é…
    if any(k in text_lower for k in ["ä½™é¢", "balance", "é’±åŒ…", "wallet", "å¤šå°‘é’±"]):
        await cmd_balance(update, context)
    elif any(k in text_lower for k in ["swap", "äº¤æ¢", "å…‘æ¢", "æ¢"]):
        await cmd_swap(update, context)
    elif any(k in text_lower for k in ["æ—¥å¿—", "log", "è®°å½•", "å†å²"]):
        await cmd_logs(update, context)
    elif any(k in text_lower for k in ["ç­–ç•¥", "strategy"]):
        await cmd_strategy(update, context)
    elif any(k in text_lower for k in ["é²¸é±¼", "whale", "å¤§æˆ·"]):
        await cmd_whale(update, context)
    elif any(k in text_lower for k in ["æ± å­", "pool", "æ–°æ± ", "æµåŠ¨æ€§"]):
        await cmd_pools(update, context)
    elif any(k in text_lower for k in ["æŒä»“", "portfolio", "ä»“ä½"]):
        uid = str(update.effective_user.id)
        await _send_portfolio_panel(update.message, uid)
    elif any(k in text_lower for k in ["é™ä»·", "limit", "æŒ‚å•"]):
        uid = str(update.effective_user.id)
        await _send_limit_panel(update.message, uid)
    elif any(k in text_lower for k in ["ä¿¡å·", "signal", "ä¹°å–ç‚¹"]):
        await _send_signals_panel(update.message)
    elif any(k in text_lower for k in ["walrus", "é“¾ä¸Š", "å­˜å‚¨"]):
        uid = str(update.effective_user.id)
        await _send_dashboard(update.message, uid)
    elif any(k in text_lower for k in ["mint", "é“¸é€ ", "jarvisusd", "stablelayer"]):
        await _send_stablelayer_panel(update.message)
    elif any(k in text_lower for k in ["burn", "èµå›", "é”€æ¯"]):
        await _send_burn_panel(update.message, str(update.effective_user.id))
    elif any(k in text_lower for k in ["yield", "æ”¶ç›Š", "ç”Ÿæ¯", "apy"]):
        await _send_yield_panel(update.message, str(update.effective_user.id))
    elif any(k in text_lower for k in ["å¸®åŠ©", "help", "æ€ä¹ˆç”¨"]):
        await cmd_help(update, context)
    elif any(k in text_lower for k in ["social", "é‚€è¯·", "refer", "æ¨è", "åˆ†äº«"]):
        await _send_social_panel(update.message, str(update.effective_user.id))
    elif any(k in text_lower for k in ["è¯­è¨€", "language", "lang", "è‹±æ–‡", "ä¸­æ–‡"]):
        await cmd_lang(update, context)
    else:
        await update.message.reply_text(
            "ğŸ¤– *Jarvis åœ¨çº¿ï¼*\n\n"
            "è¯•è¯•è¿™äº›:\n"
            "â€¢ \"ä½™é¢\" â€” æŸ¥çœ‹èµ„äº§\n"
            "â€¢ \"swap\" â€” å¼€å§‹äº¤æ˜“\n"
            "â€¢ \"æŒä»“\" â€” æŠ•èµ„ç»„åˆ\n"
            "â€¢ \"é²¸é±¼\" â€” å¤§é¢è¿½è¸ª\n"
            "â€¢ \"ä¿¡å·\" â€” AI äº¤æ˜“ä¿¡å·\n"
            "â€¢ å‘é€ CoinType æŸ¥ Token\n"
            "â€¢ /help â€” å®Œæ•´å¸®åŠ©\n\n"
            "æˆ–ç›´æ¥ä½¿ç”¨ä¸‹æ–¹æŒ‰é’® ğŸ‘‡",
            parse_mode="Markdown",
            reply_markup=main_keyboard(get_lang(str(update.effective_user.id)))
        )

# ==================== å¯åŠ¨ ====================
def main():
    log.info("ğŸ¤– Sui DeFi Jarvis v2.0 starting...")
    
    req = HTTPXRequest(proxy=PROXY, connect_timeout=30, read_timeout=30)
    get_req = HTTPXRequest(proxy=PROXY, connect_timeout=30, read_timeout=30)
    
    app = (Application.builder()
           .token(TOKEN)
           .request(req)
           .get_updates_request(get_req)
           .build())
    
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("wallet", cmd_wallet))
    app.add_handler(CommandHandler("balance", cmd_balance))
    app.add_handler(CommandHandler("swap", cmd_swap))
    app.add_handler(CommandHandler("strategy", cmd_strategy))
    app.add_handler(CommandHandler("logs", cmd_logs))
    app.add_handler(CommandHandler("whale", cmd_whale))
    app.add_handler(CommandHandler("pools", cmd_pools))
    app.add_handler(CommandHandler("portfolio", cmd_portfolio))
    app.add_handler(CommandHandler("limit", cmd_limit))
    app.add_handler(CommandHandler("signals", cmd_signals))
    app.add_handler(CommandHandler("mint", cmd_mint))
    app.add_handler(CommandHandler("burn", cmd_burn))
    app.add_handler(CommandHandler("yield", cmd_yield))
    app.add_handler(CommandHandler("stablelayer", cmd_stablelayer))
    app.add_handler(CommandHandler("lang", cmd_lang))
    app.add_handler(CommandHandler("refer", cmd_refer))
    app.add_handler(CommandHandler("social", cmd_social))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, nl_handler))
    
    log.info("ğŸ¤– @SuiJarvisBot v2.0 ACTIVE â€” The Infinite Money Glitch")
    app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    main()
